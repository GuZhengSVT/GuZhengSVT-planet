<html><head></head><body><h2 id="安装"><a href="https://mxts.jiujiuer.xyz/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%AE%89%E8%A3%85" class="headerlink" title="安装"></a>安装</h2><ul><li><p>访问<a href="https://go.dev/">这里</a> ，下载安装包进行安装即可。或者访问<a href="https://studygolang.com/dl/">这里</a>下载也可。</p></li><li><p>配置<code>go mod proxy</code>，参考<a href="https://goproxy.cn/">https://goproxy.cn</a>即可。</p></li><li><p>安装VSCode+Go插件或者Goland等开发工具都可以。</p></li></ul><hr/><p>最近得在Linux上编译个服务端程序，所以把配置方法记录一下。</p><p>源用的是USTC的。看了他们官网发现东西还真不少<del>比隔壁tuna多多了而且域名还短（确信）</del>。golang直接下载太慢所以走镜像站。链接在这，时效性应该不用太担心。</p><p><a href="https://mirrors.ustc.edu.cn/golang/go1.20.1.linux-amd64.tar.gz">https://mirrors.ustc.edu.cn/golang/go1.20.1.linux-amd64.tar.gz</a></p><p>步骤很简单，就是<code>wget</code>然后<code>tar</code>解压到指定位置最后把目录加到系统环境变量里边：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line">VER=<span class="string">&#34;1.20.1&#34;</span></span><br/><span class="line">SH=<span class="string">&#34;bash&#34;</span></span><br/><span class="line"><span class="comment"># 下载解压 &amp; 移除旧版本</span></span><br/><span class="line">wget https://mirrors.ustc.edu.cn/golang/go<span class="string">&#34;<span class="variable">$VER</span>&#34;</span>.linux-amd64.tar.gz \</span><br/><span class="line">&amp;&amp; <span class="built_in">rm</span> -rf /usr/local/go \</span><br/><span class="line">&amp;&amp; tar -C /usr/local -zxf go<span class="variable">$GO_STR</span>.linux-amd64.tar.gz</span><br/><span class="line"><span class="comment"># 如果是第一次安装且使用bash</span></span><br/><span class="line"><span class="built_in">echo</span> <span class="string">&#34;export PATH=<span class="variable">$PATH</span>:/usr/local/go/bin&#34;</span> &gt;&gt; ~/.<span class="string">&#34;<span class="variable">$SH</span>&#34;</span>rc</span><br/></pre></td></tr></tbody></table></figure><p>注意：<strong>执行上面的脚本之前请先自行验证安全性</strong>。以及，上面的脚本得用root权限执行。</p><p>然后就是设置代理。我用<a href="http://goproxy.cn/">http://goproxy.cn</a>比较多。配置也很简单：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br/><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br/></pre></td></tr></tbody></table></figure><h2 id="资料"><a href="https://mxts.jiujiuer.xyz/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E8%B5%84%E6%96%99" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://books.studygolang.com/gopl-zh">《Go语言圣经》</a></li></ul><h2 id="常见问题"><a href="https://mxts.jiujiuer.xyz/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>Go test报错</li></ul><p>报错内容：<code>call has possible formatting directive %v</code></p><p>原因：<code>go test</code> 中不能使用 <code>fmt.Println(&#34;%v&#34;, v)</code></p><h3 id="方案"><a href="https://mxts.jiujiuer.xyz/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%96%B9%E6%A1%88" class="headerlink" title="方案"></a>方案</h3><p>使用 <code>fmt.Printf(&#34;%+v&#34;, v)</code></p><h2 id="工具链"><a href="https://mxts.jiujiuer.xyz/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%B7%A5%E5%85%B7%E9%93%BE" class="headerlink" title="工具链"></a>工具链</h2><p>现代语言最大的优势就是工具链。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">go tool dist list</span><br/></pre></td></tr></tbody></table></figure><p>依赖：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">ldd [bin-name]</span><br/></pre></td></tr></tbody></table></figure><p>静态编译：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 go build xxx</span><br/><span class="line"><span class="comment"># or this</span></span><br/><span class="line">go build xxx -ldflags <span class="string">&#39;-linkmode &#34;external&#34; -extldflags &#34;-static&#34;&#39;</span></span><br/></pre></td></tr></tbody></table></figure><p>如果glibc版本不对的话，直接使用指定<code>LD_LIBRARY_PATH=.</code>的方法是无效的。</p><blockquote><p>ref:<a href="https://stackoverflow.com/questions/847179/multiple-glibc-libraries-on-a-single-host">Glibc is hard-coded in the program</a></p></blockquote><h2 id="造轮子"><a href="https://mxts.jiujiuer.xyz/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%80%A0%E8%BD%AE%E5%AD%90" class="headerlink" title="造轮子"></a>造轮子</h2><p>采用组合的方式将常用的范式写成函数，同时不失灵活性和潜力。</p><h3 id="Gin"><a href="https://mxts.jiujiuer.xyz/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Gin" class="headerlink" title="Gin"></a>Gin</h3><p>对于Gin的复用主要是添加路由的方式进行抽象和标准化，同时编写一些较为通用的API Handlers：</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">APIBuilder</span><span class="params">(router gin.IRouter, handlers ...<span class="keyword">func</span>(*gin.RouterGroup)</span></span> *gin.RouterGroup) <span class="function"><span class="keyword">func</span><span class="params">(gin.IRouter, <span class="type">string</span>)</span></span> *gin.RouterGroup {</span><br/><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(router gin.IRouter, path <span class="type">string</span>)</span></span> *gin.RouterGroup {</span><br/><span class="line">group := router.Group(path)</span><br/><span class="line"><span class="keyword">for</span> _, handler := <span class="keyword">range</span> handlers {</span><br/><span class="line">group = handler(group)</span><br/><span class="line">}</span><br/><span class="line"><span class="keyword">return</span> group</span><br/><span class="line">}</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>上面的函数实现了为一个<code>gin.RouterGroup</code>自动添加参数传入的handler列表。这样的构造器构造出的函数能用于给一个接口添加几个固定的Handler。在复用层面实现了快速的为一个结构体添加CRUD的能力，同时允许你编写自己的handler代码，以及自己的构造器。</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCRUD</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(router gin.IRouter, path <span class="type">string</span>, db *gorm.DB)</span></span> *gin.RouterGroup {</span><br/><span class="line"><span class="keyword">return</span> APIBuilder(router, <span class="function"><span class="keyword">func</span><span class="params">(group *gin.RouterGroup)</span></span> *gin.RouterGroup {</span><br/><span class="line">group.GET(<span class="string">&#34;&#34;</span>, getAll[T](db))</span><br/><span class="line">group.GET(<span class="string">&#34;/:id&#34;</span>, get[T](db))</span><br/><span class="line">group.POST(<span class="string">&#34;&#34;</span>, create[T](db))</span><br/><span class="line">group.PUT(<span class="string">&#34;/:id&#34;</span>, update[T](db))</span><br/><span class="line">group.DELETE(<span class="string">&#34;/:id&#34;</span>, <span class="built_in">delete</span>[T](db))</span><br/><span class="line"><span class="keyword">return</span> group</span><br/><span class="line">})(router, path)</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>上面展示的就是构造器的一个用法，这个构造器构造的函数能用来快速给一个结构体添加CRUD接口。</p><p>其中的Handler可以自己实现，并把自己的Handler通过上面的APIBuilder打包成一个可以快速调用的函数：</p><figure class="highlight golang"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的Handler示范</span></span><br/><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(db *gorm.DB)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br/><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> {</span><br/><span class="line"><span class="keyword">var</span> d T</span><br/><span class="line"><span class="keyword">if</span> err := c.ShouldBindJSON(&amp;d); err != <span class="literal">nil</span> {</span><br/><span class="line">c.AbortWithStatus(<span class="number">404</span>)</span><br/><span class="line">log.Println(<span class="string">&#34;[gorm]parse creation data failed: &#34;</span>, err)</span><br/><span class="line">} <span class="keyword">else</span> {</span><br/><span class="line"><span class="keyword">if</span> err := db.Create(&amp;d).Error; err != <span class="literal">nil</span> {</span><br/><span class="line">c.AbortWithStatus(<span class="number">404</span>)</span><br/><span class="line">log.Println(<span class="string">&#34;[gorm]create data failed: &#34;</span>, err)</span><br/><span class="line">} <span class="keyword">else</span> {</span><br/><span class="line">c.JSON(<span class="number">200</span>, d)</span><br/><span class="line">}</span><br/><span class="line">}</span><br/><span class="line">}</span><br/><span class="line">}</span><br/><span class="line"><span class="comment">// 简单的调用示范</span></span><br/><span class="line"><span class="keyword">type</span> Hello <span class="keyword">struct</span> {</span><br/><span class="line">    Hello <span class="type">string</span></span><br/><span class="line">    World <span class="type">string</span></span><br/><span class="line">}</span><br/><span class="line">r := gin.Default</span><br/><span class="line">db, _ := gorm.Open(sqlite.Open(<span class="string">&#34;test&#34;</span>), &amp;gorm.Config{})</span><br/><span class="line">AddCRUD[Hello](r, <span class="string">&#34;/hello&#34;</span>, db)</span><br/></pre></td></tr></tbody></table></figure><p>上面几行代码就添加了四个对于Hello的CRUD API。</p><p>而且你应该注意到了，上面crud的实现我传入了<code>gorm.DB</code>来完成实际的crud动作。主要是因为数据库查询的动作我不知道应该怎么传入，而且又不想自己搓个大而全的框架出来——简洁的函数更合我的胃口。</p><p>下一步就是尝试抽象以前自己编写的后端，试着用简洁又不失灵活度的方法创建一个渐进式辅助函数包。</p></body></html>