<html><head></head><body><p>Bash对于绝大多数任务来说够用。所以没必要太折腾，先试试Bash吧。</p><p>第一部分我会记录一些Linux自带（绝大多数情况）程序的用法，第二部分会把它们组合起来使用。</p><h2 id="命令介绍"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D" class="headerlink" title="命令介绍"></a>命令介绍</h2><h3 id="数据操作类指令"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%8C%87%E4%BB%A4" class="headerlink" title="数据操作类指令"></a>数据操作类指令</h3><p>head命令用于显示文件的开头几行，sort命令用于对文件或标准输入进行排序，可以按照字母顺序、数字大小、日期等方式进行排序，uniq命令则用于去除重复的行，可以通过参数指定只保留重复行的数量或只显示重复行。</p><p>head命令的语法：<code>head [选项] [文件]</code>。例如，要查看文件file.txt的前10行，请使用以下命令：<code>head -n 10 file.txt</code>。¹\</p><p>sort命令的语法：<code>sort [选项] [文件]</code>。例如，要按字母顺序对文件file.txt进行排序，请使用以下命令：<code>sort file.txt</code>。要按数字大小对文件进行排序，请使用以下命令：<code>sort -n file.txt</code>。</p><p>uniq命令的语法：<code>uniq [选项] [输入文件] [输出文件]</code>。例如，要从文件file.txt中删除重复的行并将结果写入新文件newfile.txt，请使用以下命令：<code>uniq file.txt newfile.txt</code>。要显示重复行及其出现次数，请使用以下命令：<code>uniq -c file.txt</code>。</p><h3 id="Bash的语法"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Bash%E7%9A%84%E8%AF%AD%E6%B3%95" class="headerlink" title="Bash的语法"></a>Bash的语法</h3><p>bash的一行语句结尾可以写分号<code>;</code>，也可以不写。用分号可以将多条指令串联起来运行，比如<code>cmd1; cmd2; cmd3; ...</code></p><p>它的管道是一个相当好用的东西，可以将几个命令的输入输出相互串起来，得到一个组合后的工具，并且管道是系统级工具，因此十分灵活且高效。比如<code>cmd1 | cmd2 | xargs cmd3 | ...</code>。</p><p>这里的<code>xargs</code>是另一个工具，它可以将它得到的stdin转化成后面跟随指令的参数列表。比如<code>find . -type f -name &#34;* *&#34; -print0 | xargs -0 rm -f</code>，它就可以将符合条件的文件作为一个参数列表传递给<code>rm -f</code>指令。另外，这里的<code>-0</code>是告诉xargs，在读入stdin时，使用 null 作为分隔符。</p><p>除了管道和分号，还有<code>&amp;&amp;</code>，也可以连接多条指令。它和分号类似，不过区别是它会检查前一条指令的运行结果（返回值），并且根据这个来决定是否运行下一条指令。例如，<code>cmd1 &amp;&amp; cmd2 &amp;&amp; cmd3</code>，这样写的话，只要任意一个指令运行失败，那么它之后的所有指令都会不执行，这样可以有效防止发生一些难以预料的情况。</p><h2 id="一些用法"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95" class="headerlink" title="一些用法"></a>一些用法</h2><p>黑魔法开始了（不是</p><h3 id="统计输出情况"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%BB%9F%E8%AE%A1%E8%BE%93%E5%87%BA%E6%83%85%E5%86%B5" class="headerlink" title="统计输出情况"></a>统计输出情况</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">./a.out | <span class="built_in">head</span> -n 100000 | <span class="built_in">sort</span> | <span class="built_in">uniq</span> -c</span><br/></pre></td></tr></tbody></table></figure><p>这样就能得到统计好的输出数据。</p><h3 id="随机输出一行"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%9A%8F%E6%9C%BA%E8%BE%93%E5%87%BA%E4%B8%80%E8%A1%8C" class="headerlink" title="随机输出一行"></a>随机输出一行</h3><p>看到同学发的抽奖现场用Python现写程序，节目效果拉满（）不过，都用Linux了，还不用Bash？</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">fname=<span class="string">&#34;lab6.c&#34;</span>; rand=$((RANDOM%$(cat &#34;<span class="variable">$fname</span>&#34; | wc -l))); sed -n <span class="string">&#34;<span class="variable">$rand</span>&#34;</span>p <span class="string">&#34;<span class="variable">$fname</span>&#34;</span></span><br/></pre></td></tr></tbody></table></figure><p>上面的命令其实是3行命令，但是每行都比较短就合成一行了。第一个和第二个都是赋值命令，设置文件名，并根据文件行数生成随机数。第三行用<code>sed</code>从文件中读取指定的行。</p><p>对于第三行指令，其实不用<code>sed</code>也行，用<code>head -n &#34;$rand&#34; | tail -n 1&#34;</code>也是能得到相同的结果。完整指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">fname=<span class="string">&#34;lab6.c&#34;</span>; rand=$((RANDOM%$(cat &#34;<span class="variable">$fname</span>&#34; | wc -l))); <span class="built_in">cat</span> <span class="variable">$fname</span> | <span class="built_in">head</span> -n <span class="string">&#34;<span class="variable">$rand</span>&#34;</span> | <span class="built_in">tail</span> -n 1</span><br/></pre></td></tr></tbody></table></figure><p>总之能看出，对于操作数据，Linux自带的工具也很强大了。</p><h3 id="保留最近三天的文件"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E4%BF%9D%E7%95%99%E6%9C%80%E8%BF%91%E4%B8%89%E5%A4%A9%E7%9A%84%E6%96%87%E4%BB%B6" class="headerlink" title="保留最近三天的文件"></a>保留最近三天的文件</h3><p>这东西用来清log和冗余备份确实好用。</p><p>清文件夹记得把-f换成-rf。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">find [target file <span class="keyword">in</span> path] -mtime +2 |xargs <span class="built_in">rm</span> -f</span><br/></pre></td></tr></tbody></table></figure><h3 id="Ubuntu内存释放"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Ubuntu%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE" class="headerlink" title="Ubuntu内存释放"></a>Ubuntu内存释放</h3><blockquote><p>2020.12.18 11:05:00</p></blockquote><p>下面的指令用来释放系统内存，只在Ubuntu上测试过。长期运行的服务器最好严密监督内存使用情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">echo 3 &gt;/proc/sys/vm/drop_caches</span><br/></pre></td></tr></tbody></table></figure><p>啊对了注意指令里是vm不是mv。</p><h3 id="ln-强大的软链接工具"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#ln-%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%B7%A5%E5%85%B7" class="headerlink" title="ln-强大的软链接工具"></a>ln-强大的软链接工具</h3><p>常用用法：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> –s 源文件 软连接文件</span><br/></pre></td></tr></tbody></table></figure><p>这可以帮我们把一个文件链接到另一个地方，类似Windows的快捷方式。</p><p>我一般会用它把正在开发的项目链接到nginx的目录下，来实时预览效果。</p><h3 id="端口占用解除"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%A7%A3%E9%99%A4" class="headerlink" title="端口占用解除"></a>端口占用解除</h3><p>有时候一些网络应用会启动失败，提示端口被占用。那么一般怎么解决呢？</p><h4 id="系统环境"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83" class="headerlink" title="系统环境"></a>系统环境</h4><p>我的系统是Ubuntu20.04，其他Linux应该也大同小异。</p><h4 id="解决步骤"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E8%A7%A3%E5%86%B3%E6%AD%A5%E9%AA%A4" class="headerlink" title="解决步骤"></a>解决步骤</h4><p>就两步。先找到进程：  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">netstat -anlp| grep 端口号</span><br/></pre></td></tr></tbody></table></figure><p>然后结束进程：  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">kill -9 进程pid</span><br/></pre></td></tr></tbody></table></figure><p>完事儿。</p><p>或者可以用awk和管道把命令缩短到一行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">netstat -anlp | grep 3000 | awk <span class="string">&#39;{print $7}&#39;</span> | awk -F <span class="string">&#39;/&#39;</span> <span class="string">&#39;{print $1}&#39;</span> | xargs <span class="built_in">kill</span> -9</span><br/></pre></td></tr></tbody></table></figure><p>不太好看但是还挺方便。起码手不疼了（</p><h3 id="nc"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#nc" class="headerlink" title="nc"></a>nc</h3><p>用<code>nc</code>可以进行局域网聊天（不是</p><p>用 <code>socat</code> 还可以群聊： 局域网内所有 Linux 机器，输入下方命令加入群聊（指 UDP 广播）（狗头）（狗头）  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">socat - UDP-DATAGRAM:255.255.255.255:12345,broadcast,<span class="built_in">bind</span>=0.0.0.0:12345</span><br/></pre></td></tr></tbody></table></figure><h3 id="根据nginx日志自动ban异常IP"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%A0%B9%E6%8D%AEnginx%E6%97%A5%E5%BF%97%E8%87%AA%E5%8A%A8ban%E5%BC%82%E5%B8%B8IP" class="headerlink" title="根据nginx日志自动ban异常IP"></a>根据nginx日志自动ban异常IP</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br/><span class="line">  </span><br/><span class="line">line=1000  </span><br/><span class="line"><span class="built_in">times</span>=10  </span><br/><span class="line">conf=/opt/nginx/conf/blockip.conf  </span><br/><span class="line">  </span><br/><span class="line"><span class="built_in">tail</span> /data/logs/nginx/access.log -n <span class="variable">$line</span> | \  </span><br/><span class="line">grep -E <span class="string">&#39;(&#34;status&#34;:&#34;404&#34;|&#34;status&#34;:&#34;302&#34;)&#39;</span> | awk <span class="string">&#39;{print $1}&#39;</span> | \  </span><br/><span class="line"><span class="built_in">sort</span> | <span class="built_in">uniq</span> -c | \  </span><br/><span class="line">awk <span class="string">&#39;$1&gt;$times{print &#34;deny &#34;$2 &#34;;&#34;}&#39;</span> &gt;&gt; <span class="variable">$conf</span>  </span><br/><span class="line">  </span><br/><span class="line">deny=$(<span class="built_in">sort</span> <span class="variable">$conf</span> | <span class="built_in">uniq</span> -c | awk <span class="string">&#39;{print &#34;deny &#34;$3}&#39;</span>)  </span><br/><span class="line"><span class="built_in">echo</span> <span class="variable">$deny</span> | sed <span class="string">&#34;s/; /;\n/g&#34;</span> &gt; <span class="variable">$conf</span>  </span><br/><span class="line">  </span><br/><span class="line">/usr/local/sbin/nginx -t || <span class="built_in">exit</span>  </span><br/><span class="line">/usr/bin/systemctl reload nginx</span><br/></pre></td></tr></tbody></table></figure><h3 id="一些小工具"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7" class="headerlink" title="一些小工具"></a>一些小工具</h3><p>lazygit ，Git 的终端界面<br/>ranger ，终端文件管理器<br/>lolcat ，对输出做渐变色处理<br/>trash ，mv 的垃圾回收站版本<br/>icdiff ，diff 的样式改进版本<br/>lsd ，带文件类型图标的 ls</p><h3 id="跟踪某网页特定内容"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E8%B7%9F%E8%B8%AA%E6%9F%90%E7%BD%91%E9%A1%B5%E7%89%B9%E5%AE%9A%E5%86%85%E5%AE%B9" class="headerlink" title="跟踪某网页特定内容"></a>跟踪某网页特定内容</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line"></span><br/><span class="line">url=<span class="string">&#34;http://v2ex.com&#34;</span></span><br/><span class="line">want=<span class="string">&#34;好玩&#34;</span></span><br/><span class="line">wget <span class="string">&#34;<span class="variable">$url</span>&#34;</span> -O contents</span><br/><span class="line"><span class="keyword">if</span></span><br/><span class="line">    result=$(<span class="built_in">cat</span> contents | ack -i <span class="string">&#34;<span class="variable">$want</span>&#34;</span>)</span><br/><span class="line"><span class="keyword">then</span></span><br/><span class="line">    <span class="built_in">echo</span> <span class="string">&#34;<span class="variable">$result</span>&#34;</span> | mail -s <span class="string">&#34;Notification&#34;</span> youe@mail.com</span><br/><span class="line"><span class="keyword">else</span></span><br/><span class="line">    <span class="built_in">echo</span> <span class="string">&#34;nothing&#34;</span></span><br/><span class="line"><span class="keyword">fi</span></span><br/></pre></td></tr></tbody></table></figure><h3 id="空间查看"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%A9%BA%E9%97%B4%E6%9F%A5%E7%9C%8B" class="headerlink" title="空间查看"></a>空间查看</h3><p>最近经常在用这个指令查看空间使用情况：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh ./* 2&gt;/dev/null | <span class="built_in">sort</span> -u</span><br/></pre></td></tr></tbody></table></figure><p>比如看下缓存占用情况啥的：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line">❯ sudo <span class="built_in">du</span> -sh ./* 2&gt;/dev/null | <span class="built_in">sort</span> -u</span><br/><span class="line">0       ./motd-news</span><br/><span class="line">1.4M    ./apparmor</span><br/><span class="line">2.0M    ./man</span><br/><span class="line">20K     ./snapd</span><br/><span class="line">228K    ./fontconfig</span><br/><span class="line">3.8M    ./debconf</span><br/><span class="line">32K     ./ldconfig</span><br/><span class="line">4.0K    ./pollinate</span><br/><span class="line">4.0K    ./private</span><br/><span class="line">8.0K    ./PackageKit</span><br/><span class="line">8.0K    ./apache2</span><br/><span class="line">8.0K    ./app-info</span><br/><span class="line">971M    ./apt</span><br/></pre></td></tr></tbody></table></figure><h3 id="用PushPlus集成事件通知服务"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%94%A8PushPlus%E9%9B%86%E6%88%90%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1" class="headerlink" title="用PushPlus集成事件通知服务"></a>用PushPlus集成事件通知服务</h3><p>这个脚本读取第一，二个命令行参数，然后发送通知。可以跟其他工具串一块，简单实现服务器监控报警功能：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line"></span><br/><span class="line">token=PUSH_PLUS_TOKEN</span><br/><span class="line">url=http://www.pushplus.plus/send</span><br/><span class="line"></span><br/><span class="line">json=<span class="string">&#34;{\&#34;token\&#34;: \&#34;<span class="variable">$token</span>\&#34;, \&#34;title\&#34;: \&#34;<span class="variable">$1</span>\&#34;, \&#34;content\&#34;: \&#34;<span class="variable">$2</span>\&#34;}&#34;</span></span><br/><span class="line">curl -H <span class="string">&#34;Content-Type: application/json&#34;</span> -X POST -d <span class="string">&#34;<span class="variable">$json</span>&#34;</span> <span class="variable">$url</span></span><br/></pre></td></tr></tbody></table></figure><p>单行脚本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -F /var/log/syslog | grep -E --line-buffered <span class="string">&#34;error|fail|warn&#34;</span> | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> bash /path/to/pushplus.sh <span class="string">&#34;服务器异常日志&#34;</span> <span class="string">&#34;<span class="variable">$line</span>&#34;</span>; <span class="keyword">done</span></span><br/></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230610193751.png" alt="添加一个“错误”消息"/></p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230610193904.png" alt="发送成功"/></p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230610193940.png"/></p><p>测试就完成了。然后直接nohup丢到后台，就能很方便地实现异常告警了。</p><ul><li>集成到crontab</li></ul><p>用了一段时间之后，发现是挺舒服，配合crontab定时触发更是自动运维的好东西。</p><p>假设有一个运维工具将信息直接输出到stdout，那么我们可以在crontab里这么写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">output=$(/path/to/script.sh); pushplus <span class="string">&#34;自动任务完成&#34;</span> <span class="string">&#34;<span class="variable">$output</span>&#34;</span></span><br/></pre></td></tr></tbody></table></figure><p>不过得先将上面的<code>pushplus.sh</code>去掉后缀放在<code>/usr/local/bin/</code>之类的地方才能全局使用。</p><h3 id="文本文件合并"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%90%88%E5%B9%B6" class="headerlink" title="文本文件合并"></a>文本文件合并</h3><p>This is technically what <code>cat</code> (“concatenate”) is supposed to do, even though most people just use it for outputting files to stdout. If you give it multiple filenames it will output them all sequentially, and then you can redirect that into a new file; in the case of all files just use <code>./*</code> (or <code>/path/to/directory/*</code> if you’re not in the directory already) and your shell will expand it to all the filenames (excluding hidden ones by default).</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">$ cat ./* &gt; merged-file</span><br/></pre></td></tr></tbody></table></figure><p>Make sure you don’t use the <code>csh</code> or <code>tcsh</code> shells for that which expand the glob <em>after</em> opening the <code>merged-file</code> for output, and that <code>merged-file</code> doesn’t exist before hand, or you’ll likely end up with an infinite loop that fills up the filesystem.</p><p>The list of files is sorted lexically. If using <code>zsh</code>, you can change the order (to numeric, or by age, size…) with glob qualifiers.</p><p>To include files in sub-directories, use:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">find . ! -path ./merged-file -type f -exec cat {} + &gt; merged-file</span><br/></pre></td></tr></tbody></table></figure><p>Though beware the list of files is not sorted and hidden files are included. <code>-type f</code> here restricts to <em>regular</em> files only as it’s unlikely you’ll want to include other types of files. With GNU <code>find</code>, you can change it to <code>-xtype f</code> to also include symlinks to regular files.</p><p>With the zsh shell,</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">cat ./**/*(-.) &gt; merged-file</span><br/></pre></td></tr></tbody></table></figure><p>Would do the same (<code>(-.)</code> achieving the equivalent of <code>-xtype f</code>) but give you a sorted list and exclude hidden files (add the <code>D</code> qualifier to bring them back). <code>zargs</code> can be used there to work around <em>argument list too long</em> errors.</p><h3 id="更改时区"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%9B%B4%E6%94%B9%E6%97%B6%E5%8C%BA" class="headerlink" title="更改时区"></a>更改时区</h3><p>今天看系统日志的时候发现时间不太对，估计应该是没设置对时区。所以就记录一下。只需要一行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">sudo timedatectl set-timezone Asia/Shanghai</span><br/><span class="line"><span class="comment"># 如果要查看所有可用时区的话</span></span><br/><span class="line">timedatectl list-timezones</span><br/><span class="line"><span class="comment"># 查看当前时区信息</span></span><br/><span class="line">timedatectl</span><br/></pre></td></tr></tbody></table></figure><p>或者也可以用创建符号链接的方式更改：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> -rf /etc/localtime &amp;&amp; \</span><br/><span class="line">sudo <span class="built_in">ln</span> -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br/></pre></td></tr></tbody></table></figure><h3 id="监控硬盘状态信息"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E7%9B%91%E6%8E%A7%E7%A1%AC%E7%9B%98%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF" class="headerlink" title="监控硬盘状态信息"></a>监控硬盘状态信息</h3><p>借助<code>smartctl</code>就能做到。这工具输出十分丰富，还能跑硬盘测试，这里演示下最简单的用法：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> DEVICE <span class="keyword">in</span> <span class="string">&#34;sda sdb sdc&#34;</span>; <span class="keyword">do</span></span><br/><span class="line">  smartctl -a <span class="variable">$DEVICE</span> | \</span><br/><span class="line">   grep <span class="string">&#39;SMART overall-health self-assessment test result&#39;</span></span><br/><span class="line"><span class="keyword">done</span></span><br/></pre></td></tr></tbody></table></figure><p>加强版，输出报告：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line">SMARTCTL=<span class="string">&#34;smartctl&#34;</span></span><br/><span class="line">DEVICES=<span class="string">&#34;sdb sdc&#34;</span></span><br/><span class="line"></span><br/><span class="line"><span class="function"><span class="title">get_model</span></span>() {</span><br/><span class="line">  DEVICE=<span class="variable">$1</span></span><br/><span class="line">  <span class="variable">$SMARTCTL</span> -i <span class="variable">$DEVICE</span> | grep <span class="string">&#34;Device Model&#34;</span> | awk <span class="string">&#39;{print $3}&#39;</span></span><br/><span class="line">}</span><br/><span class="line"><span class="function"><span class="title">check_disk</span></span>() {</span><br/><span class="line">  DEVICE=<span class="variable">$1</span></span><br/><span class="line">  MODEL=$(get_model <span class="variable">$DEVICE</span>)</span><br/><span class="line">  STATUS=$(<span class="variable">$SMARTCTL</span> -a <span class="variable">$DEVICE</span> | grep <span class="string">&#39;SMART overall-health self-assessment test result&#39;</span>)</span><br/><span class="line">  RESULT=$(<span class="built_in">echo</span> <span class="variable">$STATUS</span> | awk <span class="string">&#39;{print $NF}&#39;</span>)</span><br/><span class="line">  <span class="keyword">if</span> [ <span class="string">&#34;<span class="variable">$RESULT</span>&#34;</span> != <span class="string">&#34;PASSED&#34;</span> ]; <span class="keyword">then</span></span><br/><span class="line">    ALERTS=<span class="string">&#34;<span class="variable">$ALERTS</span>\n硬盘异常：<span class="variable">$DEVICE</span> (<span class="variable">$MODEL</span>)\n<span class="variable">$STATUS</span>\n&#34;</span> <span class="comment"># 追加到变量中，用换行符分隔不同的硬盘信息</span></span><br/><span class="line">  <span class="keyword">else</span></span><br/><span class="line">    ALERTS=<span class="string">&#34;<span class="variable">$ALERTS</span>\n硬盘正常：<span class="variable">$DEVICE</span> (<span class="variable">$MODEL</span>)\n<span class="variable">$STATUS</span>\n&#34;</span> <span class="comment"># 追加到变量中，用换行符分隔不同的硬盘信息</span></span><br/><span class="line">  <span class="keyword">fi</span></span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line">ALERTS=<span class="string">&#34;&#34;</span></span><br/><span class="line"><span class="keyword">for</span> DEV <span class="keyword">in</span> <span class="variable">$DEVICES</span>; <span class="keyword">do</span></span><br/><span class="line">  check_disk /dev/<span class="variable">$DEV</span></span><br/><span class="line"><span class="keyword">done</span></span><br/><span class="line"></span><br/><span class="line"><span class="built_in">echo</span> <span class="string">&#34;<span class="variable">$ALERTS</span>&#34;</span></span><br/></pre></td></tr></tbody></table></figure><h3 id="批量压缩"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9" class="headerlink" title="批量压缩"></a>批量压缩</h3><p>基本就是个用<code>ls</code>和<code>awk</code>组装起来的工具，没啥技术含量。使用时会把目录下的所有东西压缩为以文件为名的压缩包：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | awk <span class="string">&#39;{print &#34;zip -r \&#34;&#34; $0&#34;.zip\&#34; \&#34;&#34;$0&#34;\&#34;&#34;}&#39;</span> | bash</span><br/></pre></td></tr></tbody></table></figure><h3 id="图片生成"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90" class="headerlink" title="图片生成"></a>图片生成</h3><blockquote><p>JYY的奇妙课堂.jpg</p></blockquote><p>Linux原生支持PPM图片(Portable Pixel Map)格式。它的结构很简单：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">P6              // magic number</span><br/><span class="line">WIDTH HEIGHT</span><br/><span class="line">MAX COLOR       // number of single color, mostly be 255</span><br/><span class="line">...PIXELS       // pixels</span><br/></pre></td></tr></tbody></table></figure><p>每一个像素都是一个结构体，存储了图像的rgb信息：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">// A struct to represent a RGB pixel</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br/><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> r, g, b;</span><br/><span class="line">} Pixel;</span><br/></pre></td></tr></tbody></table></figure><p>所以，理论上可以直接<del>手写二进制</del>写出一张图片，或者用C实现：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/><span class="line">60</span><br/><span class="line">61</span><br/><span class="line">62</span><br/><span class="line">63</span><br/><span class="line">64</span><br/><span class="line">65</span><br/><span class="line">66</span><br/><span class="line">67</span><br/><span class="line">68</span><br/><span class="line">69</span><br/><span class="line">70</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br/><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">// Define the image dimensions and the maximum color value</span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH 200</span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> HEIGHT 100</span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_COLOR 255</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">// A struct to represent a RGB pixel</span></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br/><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> r, g, b;</span><br/><span class="line">} Pixel;</span><br/><span class="line"></span><br/><span class="line"><span class="comment">// A function to write a PPM image to a file</span></span><br/><span class="line"><span class="type">void</span> <span class="title function_">write_ppm</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, Pixel *image)</span> {</span><br/><span class="line">    <span class="comment">// Open the file for writing in binary mode</span></span><br/><span class="line">    FILE *fp = fopen(filename, <span class="string">&#34;wb&#34;</span>);</span><br/><span class="line">    <span class="keyword">if</span> (!fp) {</span><br/><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&#34;Error: cannot open file %s\n&#34;</span>, filename);</span><br/><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">// Write the PPM header</span></span><br/><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&#34;P6\n&#34;</span>); <span class="comment">// Magic number for binary PPM</span></span><br/><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&#34;%d %d\n&#34;</span>, WIDTH, HEIGHT); <span class="comment">// Image width and height</span></span><br/><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&#34;%d\n&#34;</span>, MAX_COLOR); <span class="comment">// Maximum color value</span></span><br/><span class="line"></span><br/><span class="line">    <span class="comment">// Write the pixel data</span></span><br/><span class="line">    fwrite(image, <span class="keyword">sizeof</span>(Pixel), WIDTH * HEIGHT, fp);</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">// Close the file</span></span><br/><span class="line">    fclose(fp);</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">// A function to create a gradient image</span></span><br/><span class="line"><span class="type">void</span> <span class="title function_">create_gradient</span><span class="params">(Pixel *image)</span> {</span><br/><span class="line">    <span class="comment">// Loop over each pixel</span></span><br/><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; HEIGHT; y++) {</span><br/><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; WIDTH; x++) {</span><br/><span class="line">            <span class="comment">// Compute the pixel index</span></span><br/><span class="line">            <span class="type">int</span> i = y * WIDTH + x;</span><br/><span class="line"></span><br/><span class="line">            <span class="comment">// Set the pixel color based on its position</span></span><br/><span class="line">            image[i].r = x * MAX_COLOR / WIDTH; <span class="comment">// Red component</span></span><br/><span class="line">            image[i].g = y * MAX_COLOR / HEIGHT; <span class="comment">// Green component</span></span><br/><span class="line">            image[i].b = (x + y) * MAX_COLOR / (WIDTH + HEIGHT); <span class="comment">// Blue component</span></span><br/><span class="line">        }</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">// The main function</span></span><br/><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br/><span class="line">    <span class="comment">// Allocate memory for the image</span></span><br/><span class="line">    Pixel *image = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Pixel) * WIDTH * HEIGHT);</span><br/><span class="line">    <span class="keyword">if</span> (!image) {</span><br/><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&#34;Error: cannot allocate memory for the image\n&#34;</span>);</span><br/><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br/><span class="line">    }</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">// Create the gradient image</span></span><br/><span class="line">    create_gradient(image);</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">// Write the image to a file</span></span><br/><span class="line">    write_ppm(<span class="string">&#34;gradient.ppm&#34;</span>, image);</span><br/><span class="line"></span><br/><span class="line">    <span class="comment">// Free the memory</span></span><br/><span class="line">    <span class="built_in">free</span>(image);</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>完成之后，可以用<code>ImageMagick</code>的<code>convert gradient.ppm gradient.jpg</code>将图片转换成jpg格式的图片。</p><h3 id="rsync的使用"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#rsync%E7%9A%84%E4%BD%BF%E7%94%A8" class="headerlink" title="rsync的使用"></a>rsync的使用</h3><blockquote><p>好东西，比<code>scp</code>好用</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步多个文件/文件夹到远程服务器目录</span></span><br/><span class="line">rsync -av files-or-dirs user@remote-server:/path/to/destination/</span><br/><span class="line"></span><br/><span class="line"><span class="comment"># 如果远程服务器的ssh端口不是默认22</span></span><br/><span class="line">rsync -av -e <span class="string">&#34;ssh -p PORT_NUMBER&#34;</span> files-or-dirs user@remote-server:/path/to/destination/</span><br/></pre></td></tr></tbody></table></figure><p>其中的<code>-a</code>代表archive，<code>-v</code>代表verbose。它的优点在于能够断点续传，以及增量同步。这样的特性使得它在镜像站搭建上也有重要地位。</p><p>另外，还可以结合<code>find</code>来做批量文件处理。比如我要将递归地将当前目录下所有以DCIM命名的文件夹合并到当前目录下，那么只需要：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> d -name <span class="string">&#34;DCIM&#34;</span> \</span><br/><span class="line">       -<span class="built_in">exec</span> rsync -av --ignore-existing {}/ ./DCIM/ \</span><br/><span class="line">       -<span class="built_in">exec</span> <span class="built_in">rmdir</span> {}</span><br/></pre></td></tr></tbody></table></figure><p>上面的指令先找到所有名为<code>DCIM</code>的目录，然后使用<code>rsync</code>将所有文件合并到当前目录的DCIM目录中，最后使用<code>rmdir</code>删除其他无用文件夹。</p><h3 id="文件管理"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86" class="headerlink" title="文件管理"></a>文件管理</h3><p>这是CLI对GUI的一次薄纱。</p><ul><li>按规则重命名所有文件</li></ul><p>例如我想移除当前目录下所有文件的<code>.</code>前缀，我就可以使用这样的命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> .*; <span class="keyword">do</span> [ -f <span class="string">&#34;<span class="variable">$file</span>&#34;</span> ] &amp;&amp; <span class="built_in">mv</span> <span class="string">&#34;<span class="variable">$file</span>&#34;</span> <span class="string">&#34;<span class="variable">${file#.}</span>&#34;</span>; <span class="keyword">done</span></span><br/></pre></td></tr></tbody></table></figure><p>还能扩展出更多的用法：</p><ul><li>重命名文件: <code>${file#.}</code>可以移除文件名的前导字符</li><li>路径修改: 可以从全路径移除特定的路径。比如<code>${full_path#/path/to/}</code>可以变换路径为相对路径</li><li>修改/删除文件后缀: <code>${file%.*}</code>会删除文件的后缀，比如文件名是<code>document.pdf</code>,<code>${file%.*}</code>就是<code>document</code></li><li>替换文件名: <code>${parameter/pattern/replacement}</code>：比如<code>${file/.old./.new.}</code>能把文件名的<code>.old.</code>换为<code>.new.</code></li></ul><h4 id="find"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#find" class="headerlink" title="find"></a>find</h4><p>这一个指令的用法就值得讲半天。<code>find</code>是查找指定路径下匹配文件的有用工具，同时还能对已有的文件执行自定义的操作。最简单的用法就是查找文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="built_in">test</span>*.md</span><br/></pre></td></tr></tbody></table></figure><p>如果要匹配多个正则求并集可以这么做：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name *.a -o -name *.b -o -name *.c</span><br/></pre></td></tr></tbody></table></figure><p>它会给出匹配的文件列表。然后使用其他工具处理就行，或者可以用<code>-exec</code>参数处理文件列表（后边再说</p><h2 id="数据操作"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C" class="headerlink" title="数据操作"></a>数据操作</h2><p>coreutils里边不少工具都是玩字符串魔术，也就是字符串处理的。这不光对于编写各宗脚本很有用，甚至在处理数据上也相当有用。特别是面对一些格式很奇怪的数据，现场找不到parser的那种，你几乎可以正则+批量操作秒了，不能秒怎么办？别急，这不还有<code>awk</code>嘛。说到这玩意，这既是个程序，也是个编程语言。它像python那样，既能用命令化的方式编辑文件，也能编写awk脚本来作为文件批量编辑的工具。</p><h3 id="文件按日期排序"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E6%96%87%E4%BB%B6%E6%8C%89%E6%97%A5%E6%9C%9F%E6%8E%92%E5%BA%8F" class="headerlink" title="文件按日期排序"></a>文件按日期排序</h3><p>刚好要给博客系统写个脚本来增加个最近文件功能。所以就写了个脚本来首先获取一个按照日期排序的文件列表。做法很简单，就是那几样老工具继续组合，不过参数倒是挺新的，因为<code>ls</code>我平时用的时候几乎就没加过参数（）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&#34;*.md&#34;</span> -print0 |\</span><br/><span class="line">    xargs -0 <span class="built_in">stat</span> -c <span class="string">&#34;%w %n&#34;</span> |\</span><br/><span class="line">    <span class="built_in">sort</span> -n |\</span><br/><span class="line">    <span class="built_in">cut</span> -d<span class="string">&#39; &#39;</span> -f4 |\</span><br/><span class="line">    <span class="built_in">head</span> -n 20</span><br/><span class="line"></span><br/></pre></td></tr></tbody></table></figure><p>一个<code>find</code>用来找出匹配文件路径，一个<code>stat</code>转换为日期+时间的形式，剩下的就是排序和字符串操作了。另外如果想倒序输出的话（从最新到最旧输出文件列表），只需要给<code>sort</code>加个<code>-r</code>参数逆向排序就行了。</p><p>把这东西加到我博客里边之后基本是这效果：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line">xeonds@localhost<span class="comment"># cd blog</span></span><br/><span class="line">Welcome back to blog, write something?</span><br/><span class="line">Recent 5 files:</span><br/><span class="line">./_posts/计算机科学/编程语言/Script/Bash学习笔记.md</span><br/><span class="line">./_posts/计算机科学/计算机视觉/计算机视觉学习笔记.md</span><br/><span class="line">./_posts/计算机科学/编程语言/JavaScript/记一次npm和nodejs安装过程.md</span><br/><span class="line">./_posts/计算机科学/开发工具/VScode使用笔记.md</span><br/><span class="line">./_posts/flutter-intro.md</span><br/><span class="line">xeonds@localhost<span class="comment"># </span></span><br/></pre></td></tr></tbody></table></figure><blockquote><p>其实现在Obsidian用的少了，反而是Vim用的更多了。一个是Vim性能和资源占用上确实能吊着前者打，另一个是Obsidian对于Vim的支持还是比较有限和割裂（比如<code>&lt;Ctrl+C&gt;</code>和<code>&lt;Ctrl+V&gt;</code>的处理，比如中文输入法的支持，在我这边的感知是达不到原生Vim的体感的）。不过Vim这边怎么复制粘贴图片是个大问题，不过有必要<del>不咕咕咕</del>的话，也许写个脚本也能搞定。</p></blockquote><h3 id="进制转换"><a href="https://mxts.jiujiuer.xyz/2023/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Script/Bash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2" class="headerlink" title="进制转换"></a>进制转换</h3><p>Bash里边有个printf调用，好像是shell内建的POSIX标准命令。也是突然想起来能这么用的：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#39;%x\n&#39;</span> 2024</span><br/></pre></td></tr></tbody></table></figure><p>或者，也可以用<code>bc</code>或者<code>dc</code>解决：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#39;obase=16; 9999999999999999999999&#39;</span> | bc</span><br/><span class="line">21E19E0C9BAB23FFFFF</span><br/><span class="line">$ <span class="built_in">echo</span> <span class="string">&#39;16o 9999999999999999999999 p&#39;</span> | dc</span><br/><span class="line">21E19E0C9BAB23FFFFF</span><br/></pre></td></tr></tbody></table></figure><blockquote><p>ref:<a href="https://unix.stackexchange.com/questions/191205/bash-base-conversion-from-decimal-to-hex">BASH base conversion from decimal to hex</a></p></blockquote></body></html>