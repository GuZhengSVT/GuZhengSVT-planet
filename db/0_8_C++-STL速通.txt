<html><head></head><body><p>C++用的比较少，最近准备试试CSP。于是就得赶紧学学STL。以前是用过，但是没咋记下来。</p><p>想查看所有std实体的话，使用下面的指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">apropos -r <span class="string">&#39;^std&#39;</span> | vim -</span><br/></pre></td></tr></tbody></table></figure><p>关于<code>apropos</code>，它是LINUX系统中的一个命令，用来通过关键字查找定位手册页的名字和描述。 它相当于使用带有-k选项的man命令。 每个手册页里都有一个简短的描述。 apropos在这个描述中查找keyword。这是使用<code>man</code> 帮助文档的一个好工具。</p><h2 id="分类"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#%E5%88%86%E7%B1%BB" class="headerlink" title="分类"></a>分类</h2><ul><li>顺序式：<code>vector, list, deque</code></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>()</span><br/><span class="line"><span class="built_in">end</span>()</span><br/><span class="line"><span class="built_in">rbegin</span>()</span><br/><span class="line"><span class="built_in">rend</span>()</span><br/><span class="line"><span class="built_in">front</span>()</span><br/><span class="line"><span class="built_in">back</span>()</span><br/><span class="line"><span class="built_in">erase</span>()</span><br/><span class="line"><span class="built_in">clear</span>()</span><br/><span class="line"><span class="built_in">push_back</span>()</span><br/><span class="line"><span class="built_in">pop_back</span>()</span><br/><span class="line"><span class="built_in">insert</span>()</span><br/></pre></td></tr></tbody></table></figure><h3 id="Vector"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#Vector" class="headerlink" title="Vector"></a>Vector</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br/></pre></td></tr></tbody></table></figure><p>简而言之就是数组，但是优化过，缝合了诸如队列、栈一类的特性。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">// 声明一个空的vector</span></span><br/><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br/><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 大小为10, 初始值为1</span></span><br/><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(oldVec)</span></span>;</span><br/><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(oldVec.begin(), dolVec.begin()+<span class="number">3</span>)</span></span>;</span><br/><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br/><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(arr, arr+<span class="number">5</span>)</span></span>; <span class="comment">// 用数组初始化vec</span></span><br/><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(&amp;arr[<span class="number">0</span>], &amp;arr[<span class="number">5</span>])</span></span>; <span class="comment">// 用数组初始化vec, 注意这里是超尾, 与end相对应</span></span><br/></pre></td></tr></tbody></table></figure><p>那么如果我希望直接在下标为5的位置直接放入这个3呢，那不是需要先往里塞入5个0才可以么？这种情况，我们就可以定义一下vector的长度，然后就可以当做数组一样用了</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br/><span class="line">a[<span class="number">5</span>] = <span class="number">3</span>;</span><br/></pre></td></tr></tbody></table></figure><h3 id="List"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#List" class="headerlink" title="List"></a>List</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br/></pre></td></tr></tbody></table></figure><p>双向链表。因此并不支持随机访问。尾部插入元素效率很高。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; l;</span><br/><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 含有5个元素的list, 初始值为0</span></span><br/><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">// 含有10个元素的list, 初始值为1</span></span><br/><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(oldL)</span></span>; <span class="comment">// 复制构造</span></span><br/><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(oldL.begin(), oldL.end())</span></span>;</span><br/><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br/><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(arr, arr+<span class="number">5</span>)</span></span>; <span class="comment">// 用数组初始化list</span></span><br/><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(&amp;arr[<span class="number">1</span>], &amp;arr[<span class="number">5</span>])</span></span>; <span class="comment">// 用数组初始化list</span></span><br/><span class="line"></span><br/><span class="line">list.<span class="built_in">merge</span>() <span class="comment">// 合并两个list</span></span><br/><span class="line">list.<span class="built_in">remove</span>()</span><br/><span class="line">list.<span class="built_in">remove_if</span>() <span class="comment">// 按指定条件删除元素</span></span><br/><span class="line">list.<span class="built_in">reverse</span>() <span class="comment">// 逆置list元素</span></span><br/><span class="line">list.<span class="built_in">sort</span>() <span class="comment">// 排序</span></span><br/><span class="line">list.<span class="built_in">unique</span>() <span class="comment">// 删除重复元素</span></span><br/><span class="line">list.<span class="built_in">splice</span>() <span class="comment">// 从另一个 list 中移动元素</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">// Most used functions</span></span><br/><span class="line"></span><br/><span class="line"><span class="built_in">push_front</span>() <span class="comment">// vector 没有该函数</span></span><br/><span class="line"><span class="built_in">pop_front</span>() <span class="comment">// vector 没有该函数</span></span><br/></pre></td></tr></tbody></table></figure><h3 id="Deque"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#Deque" class="headerlink" title="Deque"></a>Deque</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br/></pre></td></tr></tbody></table></figure><p>双端队列。每个元素在内存上是连续的，类似vector，是它的升级版。它有高效的首尾插入/删除操作。实现方法相当于list和vector的折衷。</p><p>它支持随机访问和<code>at()</code>。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>()</span><br/><span class="line"><span class="built_in">pop_back</span>()</span><br/><span class="line"><span class="built_in">push_front</span>() <span class="comment">// vector 没有该函数</span></span><br/><span class="line"><span class="built_in">pop_front</span>() <span class="comment">// vector 没有该函数</span></span><br/></pre></td></tr></tbody></table></figure><ul><li>关联式容器： <code>map, unordered_map, multimap, unordered_multimap, set, unordered_set, multiset, unordered_multiset</code></li></ul><h3 id="Map"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br/></pre></td></tr></tbody></table></figure><p>一种基于红黑树的键值对数据结构。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据插入, 复杂度为 logn</span></span><br/><span class="line">map.<span class="built_in">insert</span>({key, value});</span><br/><span class="line">map[key] = value;</span><br/><span class="line"><span class="comment">// 移除, 复杂度为 logn</span></span><br/><span class="line">map.<span class="built_in">erase</span>(key)</span><br/><span class="line"><span class="comment">// 搜索, 复杂度为 logn</span></span><br/><span class="line">map.<span class="built_in">find</span>()</span><br/><span class="line">map[key]</span><br/><span class="line"></span><br/><span class="line">map.<span class="built_in">count</span>() <span class="comment">// 返回匹配特定键的元素数量, 对数复杂度</span></span><br/><span class="line">map.<span class="built_in">contains</span>()</span><br/><span class="line">map.<span class="built_in">equal_range</span>()</span><br/><span class="line">map.<span class="built_in">lower_bound</span>()</span><br/><span class="line">map.<span class="built_in">upper_bound</span>()</span><br/></pre></td></tr></tbody></table></figure><h3 id="Unordered-Map"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#Unordered-Map" class="headerlink" title="Unordered-Map"></a>Unordered-Map</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br/></pre></td></tr></tbody></table></figure><p>区别于前者使用红黑树实现，它使用哈希函数实现，因此元素无序。</p><p>注意，默认情况下，它只支持使用<code>int</code>作为键，其他类型是不合法的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据插入, 复杂度为 logn</span></span><br/><span class="line">map.<span class="built_in">insert</span>({key, value});</span><br/><span class="line">map[key] = value;</span><br/><span class="line"><span class="comment">// 移除, 复杂度为 logn</span></span><br/><span class="line">map.<span class="built_in">erase</span>(key)</span><br/><span class="line"><span class="comment">// 搜索, 复杂度为 logn</span></span><br/><span class="line">map.<span class="built_in">find</span>()</span><br/><span class="line">map[key]</span><br/><span class="line"></span><br/><span class="line">map.<span class="built_in">count</span>() <span class="comment">// 返回匹配特定键的元素数量, 对数复杂度</span></span><br/><span class="line">map.<span class="built_in">contains</span>()</span><br/><span class="line">map.<span class="built_in">equal_range</span>()</span><br/><span class="line">map.<span class="built_in">lower_bound</span>()</span><br/><span class="line">map.<span class="built_in">upper_bound</span>()</span><br/></pre></td></tr></tbody></table></figure><h3 id="Set"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#Set" class="headerlink" title="Set"></a>Set</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br/></pre></td></tr></tbody></table></figure><p>set 是一个关键字集合, 其中的关键字 不可重复, 其底层采用红黑树实现, 因此集合中的元素是 有序 的, 在 set 容器上进行的搜索, 插入和移除等操作都是<strong>对数复杂度</strong>的.</p><p>特有操作：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>() <span class="comment">// 返回指向首个不小于给定键的元素的迭代器</span></span><br/><span class="line"><span class="built_in">upper_bound</span>() <span class="comment">// 返回指向首个大于给定键的元素的迭代器</span></span><br/><span class="line"><span class="built_in">erase_if</span>()</span><br/></pre></td></tr></tbody></table></figure><h3 id="Stack"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br/><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br/><span class="line">s.<span class="built_in">push</span>(data);</span><br/><span class="line">s.<span class="built_in">pop</span>();</span><br/><span class="line">s.<span class="built_in">top</span>();    <span class="comment">// get value of top</span></span><br/><span class="line">s.<span class="built_in">empty</span>()   <span class="comment">// judge whether stack is empty</span></span><br/></pre></td></tr></tbody></table></figure><h2 id="Reference"><a href="https://xeonds.github.io/2023/09/14/cpp-stl/#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://stackoverflow.com/questions/5293737/where-are-the-man-pages-for-c">StackOverflow - Where are the man pages for C++? [closed]</a></li><li><a href="https://forever97.top/2020/10/21/Re0-2/">forever97</a></li><li><a href="https://baike.baidu.com/item/apropos/15852795">百度百科 - apropos</a></li></ul></body></html>