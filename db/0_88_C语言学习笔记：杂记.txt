<html><head></head><body><h2 id="奇怪的赋值"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E5%A5%87%E6%80%AA%E7%9A%84%E8%B5%8B%E5%80%BC" class="headerlink" title="奇怪的赋值"></a>奇怪的赋值</h2><p>先上两个赋值语句。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br/><span class="line"><span class="comment">//版本1</span></span><br/><span class="line"><span class="type">float</span> c_1 = (a<span class="number">-9</span>)*<span class="number">5</span>/<span class="number">9</span>;</span><br/><span class="line"></span><br/><span class="line"><span class="comment">//版本2</span></span><br/><span class="line"><span class="type">float</span> c_2 = (a<span class="number">-9</span>)*<span class="number">5</span>/<span class="number">9.0f</span>;</span><br/></pre></td></tr></tbody></table></figure><p>那么请问，c_1是否和c_2的值相等呢？</p><p><strong>不相等。</strong></p><p>因为这里发生了隐式类型转换。对于第一个语句，<code>5/9</code>的值实际上是整数，这是因为9和5都是整数。第二个语句则会得到符合我们直觉的结果。</p><p>虽然现如今很多编译器已经支持这种自动转换，但是为了确保兼容性，我们还是严格按照数据类型编写赋值语句吧。</p><p>这里再说一句，编译器遇到这样的表达式时，会进行自动类型转换，将所有操作数的类型转换为其中容纳范围最大的数据类型。顺序是<code>short-&gt;int-&gt;unsigned int-&gt;long-&gt;unsigned long-&gt;float-&gt;double-&gt;long double</code></p><h2 id="无限读取"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E6%97%A0%E9%99%90%E8%AF%BB%E5%8F%96" class="headerlink" title="无限读取"></a>无限读取</h2><p>先来看看这个语句。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ch;</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">while</span>((ch = getchar()) != <span class="string">&#39;\n&#39;</span>)</span><br/><span class="line">{</span><br/><span class="line">    <span class="comment">//statements</span></span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>在一些情况下，它的确可以正常运行。但是，在一些特殊情况下，它会无限输出。因为它的结束条件是读入的字符不是换行符。换句话来说，就是此处while的边界条件太少了，以至于循环很可能无限执行下去，导致输出超限。</p><p>之前我也不是很清楚，所以说得很抽象。实际上，这里需要使用<code>while((ch=getchar())!=EOF)</code>，这才是正确的终止条件。</p><p>除此之外，<code>ch</code>务必声明为<code>int</code>类型。因为<code>char</code>类型实际上就是短整型，所以读取的字符如果ASCII码过大（超过256）就会发生溢出，从而有可能和<code>EOF</code>的值相等，从而异常退出。</p><h2 id="指针？"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E6%8C%87%E9%92%88%EF%BC%9F" class="headerlink" title="指针？"></a>指针？</h2><p>请看下面的赋值语句，想想a,b的数据类型。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* a,b;</span><br/></pre></td></tr></tbody></table></figure><p>答案是：a是指向int的指针，而b是<strong>int类型的变量</strong>。原因是什么？因为*是和a在一起的。所以通常我们不会这么写，我们一般会把*放在靠近变量的一侧来避免混淆。</p><p>再来看看这个。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR int*</span></span><br/><span class="line"></span><br/><span class="line">......</span><br/><span class="line">INTPTR a,b,c;</span><br/></pre></td></tr></tbody></table></figure><p>其中，只有a是指向int的指针类型。b和c都是整数类型。所以，宏指令并不能很好地处理指针类型。因此我们通常会用typedef取而代之。</p><h2 id="转义符"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E8%BD%AC%E4%B9%89%E7%AC%A6" class="headerlink" title="转义符"></a>转义符</h2><p>这是转义字符<code>\</code>。注意，对于printf()而言，未定义的转义字符会直接输出反斜杠后的字符。</p><p>另外，有一种三符号系统，用<code>\??*</code>来表示其他符号。所以连续使用问号时请务必注意。</p><h2 id="单引号，双引号"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E5%8D%95%E5%BC%95%E5%8F%B7%EF%BC%8C%E5%8F%8C%E5%BC%95%E5%8F%B7" class="headerlink" title="单引号，双引号"></a>单引号，双引号</h2><p>在很多语言中，单引号和双引号是等效的（比如Python）。但是对于C语言而言，单引号内<strong>只能表示单个字符</strong>，而双引号<strong>只能表示字符串</strong>。</p><h2 id="奇怪的赋值2"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E5%A5%87%E6%80%AA%E7%9A%84%E8%B5%8B%E5%80%BC2" class="headerlink" title="奇怪的赋值2"></a>奇怪的赋值2</h2><p>来看看这个。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">r=s+(t=u-v)/<span class="number">3</span>;</span><br/></pre></td></tr></tbody></table></figure><p>这个表达式合法吗？合法。因为C语言中，赋值并不是语句，而是表达式。所以它可以出现在任何允许出现的地方。</p><p>既然是表达式，那么它就有返回值。 赋值表达式的值就是左操作数的新值。</p><p>再来看看这个语句。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br/><span class="line">(a=<span class="number">4</span>)=<span class="number">3</span>*<span class="number">4</span>;</span><br/></pre></td></tr></tbody></table></figure><p>合法吗？不合法。括号项是表达式，它作为另一个赋值表达式的左值参与赋值运算。但是左值不能是常量，而<code>(a=4)</code>的值是4，显然不能被赋值。</p><h2 id="逗号运算符"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符将几个表达式相连接，构成一个表达式。这个表达式的值就是<strong>最右边的子表达式的值</strong>。</p><p>在这里有一个小技巧：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression1)</span><br/><span class="line">    statement1,</span><br/><span class="line">statement2;</span><br/></pre></td></tr></tbody></table></figure><p>事实上这两条语句都会循环运行。此处的逗号运算符将两条语句合并成一条语句。</p><p>除了这里可以这么用，可以在循环条件中这么写：如果这么做能使程序更优秀的话。</p><h2 id="for语句"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#for%E8%AF%AD%E5%8F%A5" class="headerlink" title="for语句"></a>for语句</h2><p>C的<code>for</code>是<code>while</code>的一种常用语句组合形式的简写法。语法如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(expression1; expression2; expression3)</span><br/><span class="line">    statement;</span><br/></pre></td></tr></tbody></table></figure><p>其中<code>statement</code>称为循环体。<code>expression1</code>为<strong>初始化</strong>部分，只在循环开始时执行一次。<code>expression2</code>称为<strong>条件</strong>部分，它在循环体每次执行前都要执行一次，和<code>while</code>语句中的表达式一样。<code>expression3</code>称为<strong>调整</strong>部分，它在循环体每次执行完毕，在条件部分即将执行前执行。</p><p>这三个表达式都是可省略的。若省略条件部分，表示测试的值始终为真。</p><h2 id="表达式和语句"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5" class="headerlink" title="表达式和语句"></a>表达式和语句</h2><p>表达式可以出现在任何地方，而语句只能出现在单独的一行。C语言没有赋值语句，它只有赋值表达式。</p><p>所以嘛，表达式能出现的地方，都可以赋值，这就有了上面那个奇怪的赋值2。</p><h2 id="代码块与声明"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E5%A3%B0%E6%98%8E" class="headerlink" title="代码块与声明"></a>代码块与声明</h2><p>我们知道，变量是有作用域的。也就是说，它可以声明在最外层，或者是代码块开头。其实，函数的声明也一样。看看这个：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br/><span class="line"></span><br/><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br/><span class="line">{</span><br/><span class="line">    <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> a)</span></span><br/><span class="line">    {</span><br/><span class="line">        <span class="keyword">return</span> a*a;</span><br/><span class="line">    }</span><br/><span class="line">    <span class="type">int</span> num;</span><br/><span class="line"></span><br/><span class="line">    <span class="built_in">scanf</span>(<span class="string">&#34;%d&#34;</span>,&amp;num);</span><br/><span class="line">    <span class="built_in">printf</span>(<span class="string">&#34;%d&#34;</span>,square(num));</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>一样，它也可以使用函数原型。只需要在前面声明函数原型，在之后写上函数实现就行。不过，以这种形式只能在这个语句块中使用。所以，<del>我们可以随便套娃</del>我们可以声明任意多重的函数。不过注意作用域问题：内层声明会在当前语句块内覆盖重名的外层声明。</p><p>另外还有，关于代码块，它并非必须和<code>for</code>等一起出现。它也可以单独出现。和一起出现时一样，它形成了一个块作用域，可以划定更精细的作用域和生命周期。</p><blockquote><p>关于<code>main()</code>函数</p><p>其实它真的和其他函数一样是平等的。编译器编译时并没有区别对待它，但是连接器在链接过程，会将一个中间文件链接过来，那个文件指明了程序的入口点：<code>main()</code>。<br/>程序只是从<code>main()</code>开始执行，仅此而已。<br/>既然如此，那么其他函数的操作，在<code>main()</code>函数，也可以使用了。比如递归（虽然这种用法极度罕见），被别的函数调用等各种操作。</p></blockquote><h2 id="可变参数列表的函数"><a href="https://mxts.jiujiuer.xyz/2021/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%C2%B7C++/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%9D%82%E8%AE%B0/#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%E7%9A%84%E5%87%BD%E6%95%B0" class="headerlink" title="可变参数列表的函数"></a>可变参数列表的函数</h2><p>需要用宏来实现。这些宏位于<code>stdargs.h</code>头文件，是C标准库的一部分。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br/><span class="line"></span><br/><span class="line"><span class="type">float</span> <span class="title function_">avarage</span><span class="params">(<span class="type">int</span> n_values, ...)</span></span><br/><span class="line">{</span><br/><span class="line">    va_list  var_arg;</span><br/><span class="line">    <span class="type">int</span> count;</span><br/><span class="line">    <span class="type">float</span> sum=<span class="number">0</span>;</span><br/><span class="line"></span><br/><span class="line">    va_start(var_arg, n_values);</span><br/><span class="line">    <span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;n_values;count++)</span><br/><span class="line">        sum+=va_arg(var_arg, <span class="type">int</span>);</span><br/><span class="line">    va_end(var_arg);</span><br/><span class="line"></span><br/><span class="line">    <span class="keyword">return</span> sum/n_values;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure></body></html>