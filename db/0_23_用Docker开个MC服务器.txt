<html><head></head><body><p>前段时间好好学了下Docker，于是想试着用它去部署一些比较麻烦的服务端。所以首先就是试试MC了，毕竟能实现服务端跟地图数据分离以及服务端自动化部署，便于迁移确实很爽。</p><p>虽然MC服务端的性能敏感性比较高，但是Docker+MC的性能问题比较小，因为基于KVM，虚拟化由内核支持，所以Docker性能开销相当小，日用基本可以忽略。</p><h2 id="目标"><a href="https://xeonds.github.io/2023/06/07/%E6%B8%B8%E6%88%8F/Minecraft/%E7%94%A8Docker%E5%BC%80%E4%B8%AAMC%E6%9C%8D%E5%8A%A1%E5%99%A8/#%E7%9B%AE%E6%A0%87" class="headerlink" title="目标"></a>目标</h2><p>部署好之后，目录下应该只有一个地图文件夹，一个服务端程序，以及一个明确指示了地图文件夹和服务端程序路径的dockerfile。如果使用docker-compose去实现包括mc服务端的外围功能（比如bluemap等地图功能，以及geyser这样的be兼容转换服务端），那也可以，不过得保证数据程序的分离，以及可维护、易于修改的特质。</p><p>基于上面的目标，可以使用Volume完成资源的映射。我们需要的只是一个基础的jre镜像。</p><h2 id="代码"><a href="https://xeonds.github.io/2023/06/07/%E6%B8%B8%E6%88%8F/Minecraft/%E7%94%A8Docker%E5%BC%80%E4%B8%AAMC%E6%9C%8D%E5%8A%A1%E5%99%A8/#%E4%BB%A3%E7%A0%81" class="headerlink" title="代码"></a>代码</h2><p>Dockerfile很简单，就是基础的jre镜像，以及启动指令。</p><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">17</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br/><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#34;eula=true&#34;</span> &gt; /app/eula.txt</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&#34;java&#34;</span>, <span class="string">&#34;-jar&#34;</span>, <span class="string">&#34;server.jar&#34;</span>]</span></span><br/></pre></td></tr></tbody></table></figure><p>然后是启动脚本，我将几个常用指令封装成一个Bash脚本了：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment"># 获取第一个参数</span></span><br/><span class="line">action=<span class="variable">$1</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment"># 根据参数执行不同的操作</span></span><br/><span class="line"><span class="keyword">case</span> <span class="variable">$action</span> <span class="keyword">in</span></span><br/><span class="line">  run) <span class="comment"># 运行容器</span></span><br/><span class="line">    docker run -d \</span><br/><span class="line">      -p 25565:25565 \</span><br/><span class="line">      -v $(<span class="built_in">pwd</span>)/world:/app/world \</span><br/><span class="line">      -v $(<span class="built_in">pwd</span>)/server.jar:/app/server.jar \</span><br/><span class="line">      -v $(<span class="built_in">pwd</span>)/server.properties:/app/server.properties \</span><br/><span class="line">      --name mc \</span><br/><span class="line">      mc-server</span><br/><span class="line">    ;;</span><br/><span class="line">  build) <span class="comment"># 构建镜像</span></span><br/><span class="line">    docker build -t mc-server .</span><br/><span class="line">    ;;</span><br/><span class="line">  stop) <span class="comment"># 停止容器</span></span><br/><span class="line">    docker stop mc</span><br/><span class="line">    ;;</span><br/><span class="line">  start) <span class="comment"># 启动容器</span></span><br/><span class="line">    docker start mc</span><br/><span class="line">    ;;</span><br/><span class="line">  restart) <span class="comment"># 重启容器</span></span><br/><span class="line">    docker restart mc</span><br/><span class="line">    ;;</span><br/><span class="line">  backup) <span class="comment"># 备份文件</span></span><br/><span class="line">    timestamp=$(<span class="built_in">date</span> +%Y%m%d%H%M%S)</span><br/><span class="line">    zip -r [backup]mc-server-<span class="variable">$timestamp</span>.zip world server.properties mc.sh Dockerfile server.jar</span><br/><span class="line">    ;;</span><br/><span class="line">  <span class="built_in">log</span>) <span class="comment"># 输出日志</span></span><br/><span class="line">    docker logs -f mc</span><br/><span class="line">    ;;</span><br/><span class="line">  sh) <span class="comment"># 进入shell</span></span><br/><span class="line">    docker <span class="built_in">exec</span> -it mc sh</span><br/><span class="line">    ;;</span><br/><span class="line"></span><br/><span class="line">  *) <span class="comment"># 输出帮助信息并退出</span></span><br/><span class="line">    <span class="built_in">echo</span> <span class="string">&#34;Usage: <span class="variable">$0</span> {run|build|stop|start|restart|log|sh}&#34;</span></span><br/><span class="line">    <span class="built_in">exit</span> 1</span><br/><span class="line">    ;;</span><br/><span class="line"><span class="keyword">esac</span></span><br/></pre></td></tr></tbody></table></figure><p>然后，在保证目录下有<code>server.jar</code>和<code>server.properties</code>的前提下，使用<code>./mc.sh run</code>来初始化并运行服务端。剩下的用法参考上面的代码，或者参考<a href="https://github.com/xeonds/docker-mc/">这里</a>。</p><h2 id="外围"><a href="https://xeonds.github.io/2023/06/07/%E6%B8%B8%E6%88%8F/Minecraft/%E7%94%A8Docker%E5%BC%80%E4%B8%AAMC%E6%9C%8D%E5%8A%A1%E5%99%A8/#%E5%A4%96%E5%9B%B4" class="headerlink" title="外围"></a>外围</h2><p>开了服务器之后，肯定需要对公网/内网开放。我在这里用了一个frp的镜像，同样也将它封装为了启动脚本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment"># 定义容器名称和配置文件路径</span></span><br/><span class="line">CONTAINER_NAME=frpc</span><br/><span class="line">CONFIG_FILE=$(<span class="built_in">pwd</span>)/frpc.ini</span><br/><span class="line"></span><br/><span class="line"><span class="comment"># 检查参数个数</span></span><br/><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]; <span class="keyword">then</span></span><br/><span class="line">    <span class="built_in">echo</span> <span class="string">&#34;Usage: <span class="variable">$0</span> run|start|stop|restart&#34;</span></span><br/><span class="line">    <span class="built_in">exit</span> 1</span><br/><span class="line"><span class="keyword">fi</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment"># 根据参数执行相应操作</span></span><br/><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br/><span class="line">    run)</span><br/><span class="line">        <span class="comment"># 部署容器</span></span><br/><span class="line">        docker run --restart=always --network host -d -v <span class="variable">$CONFIG_FILE</span>:/etc/frp/frpc.ini --name <span class="variable">$CONTAINER_NAME</span> snowdreamtech/frpc</span><br/><span class="line">        ;;</span><br/><span class="line">    start)</span><br/><span class="line">        <span class="comment"># 启动容器</span></span><br/><span class="line">        docker start <span class="variable">$CONTAINER_NAME</span></span><br/><span class="line">        ;;</span><br/><span class="line">    stop)</span><br/><span class="line">        <span class="comment"># 停止容器</span></span><br/><span class="line">        docker stop <span class="variable">$CONTAINER_NAME</span></span><br/><span class="line">        ;;</span><br/><span class="line">    restart)</span><br/><span class="line">        <span class="comment"># 重启容器</span></span><br/><span class="line">        docker restart <span class="variable">$CONTAINER_NAME</span></span><br/><span class="line">        ;;</span><br/><span class="line"> <span class="built_in">log</span>) <span class="comment"># 输出日志</span></span><br/><span class="line">    docker logs -f <span class="variable">$CONTAINER_NAME</span></span><br/><span class="line">    ;;</span><br/><span class="line">  sh) <span class="comment"># 进入shell</span></span><br/><span class="line">    docker <span class="built_in">exec</span> -it <span class="variable">$CONTAINER_NAME</span> sh</span><br/><span class="line">    ;;</span><br/><span class="line">    *)</span><br/><span class="line">        <span class="comment"># 无效参数</span></span><br/><span class="line">        <span class="built_in">echo</span> <span class="string">&#34;Invalid argument: <span class="variable">$1</span>&#34;</span></span><br/><span class="line">        <span class="built_in">echo</span> <span class="string">&#34;Usage: <span class="variable">$0</span> run|start|stop|restart|log&#34;</span></span><br/><span class="line">        <span class="built_in">exit</span> 2</span><br/><span class="line">        ;;</span><br/><span class="line"><span class="keyword">esac</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment"># 打印容器状态</span></span><br/><span class="line">docker ps -a | grep <span class="variable">$CONTAINER_NAME</span></span><br/></pre></td></tr></tbody></table></figure><p>同样，保证目录下有一个<code>frpc.ini</code>文件。每次编辑完成后，需要删除原来的容器重新启动一个。</p><p>还有一个使用<code>pushplus</code>简单的监控脚本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line"></span><br/><span class="line">token=<span class="string">&#34;your_token_here&#34;</span></span><br/><span class="line">url=http://www.pushplus.plus/send</span><br/><span class="line"></span><br/><span class="line">bash mc.sh <span class="built_in">log</span> | grep -E --line-buffered <span class="string">&#34;error|fail|warn&#34;</span> |\</span><br/><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line; </span><br/><span class="line"><span class="keyword">do</span> json=<span class="string">&#34;{\&#34;token\&#34;: \&#34;<span class="variable">$token</span>\&#34;, \&#34;title\&#34;: \&#34;MC服务端异常报警\&#34;, \&#34;content\&#34;: \&#34;<span class="variable">$line</span>\&#34;}&#34;</span></span><br/><span class="line">curl -H <span class="string">&#34;Content-Type: application/json&#34;</span> -X POST -d <span class="string">&#34;<span class="variable">$json</span>&#34;</span> <span class="variable">$url</span></span><br/><span class="line"><span class="keyword">done</span></span><br/></pre></td></tr></tbody></table></figure><p>它会<strong>每次从日志开始读取日志</strong>，将报错信息发送给PushPlus API。我一般会在微信上收报警消息。不过每次从日志开始读取日志确实不太好（会重复发送以前的错误信息）。这个回头得改一改。要么每次退出时清空日志，要么设置个读取行指示的全局变量。</p><p>就是这样啦。</p></body></html>