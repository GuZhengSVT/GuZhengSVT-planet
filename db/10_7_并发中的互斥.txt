<html><head></head><body><p>好家伙, 我已经三个多月没写东西啦!</p><p>最近两天先写点基础的, 这两天在看jyy的操作系统课和6.S081, 恶补一下操作系统的知识.</p><p>过几天写一下这个学期一直在研究的分布式系统, Raft啥的.</p><span id="more"></span><h2 id="互斥"><a href="https://honoka.tech/2022/08/21/mutex/#%E4%BA%92%E6%96%A5" class="headerlink" title="互斥"></a>互斥</h2><p>互斥就是禁止多个线程同时访问同一个资源, 这个资源叫做临界资源.并行编程最大的几个问题之一是多个线程的执行流会被来回切换, 你永远想象不到一个线程会在什么时候被打断.还有就是编译器, 现代处理器都会在不同级别上乱序执行, 不过这个也不是今天讨论的重点, 这个主要靠barrier去解决.</p><p>比如这样的:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> locked <span class="token operator">=</span> UNLOCK<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">critical_section</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>retry<span class="token operator">:</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>locked <span class="token operator">!=</span> UNLOCK<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">goto</span> retry<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  locked <span class="token operator">=</span> LOCK<span class="token punctuation">;</span>  <span class="token comment">// critical section</span>  locked <span class="token operator">=</span> UNLOCK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个失败的锁的尝试, 多个线程可能同时判断到locked为unlock.</p><p>重点在于处理器不保证load+store的原子性</p><h2 id="Peterson算法"><a href="https://honoka.tech/2022/08/21/mutex/#Peterson%E7%AE%97%E6%B3%95" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><p>Peterson算法实现了两个线程的互斥, 不需要任何复杂原子操作.</p><p>两个线程争夺临界区: 每个线程自己有个标志, 临界区有个标志turn</p><ol><li>把自己的标志亮起来.</li><li>把临界区的标志turn改为 <strong>对方</strong>.</li><li>如果对方的标志亮起来, 并且turn是对方, 就等待, 否则进入临界区.</li><li>出临界区, 熄灭自己的标志.</li></ol><p>感性理解:</p><ol><li>如果只有一个线程想要进入临界区, 那显然正确.</li><li>两个线程同时想要进入临界区, 两个线程都会把自己的标志亮起来, 并且去修改turn.</li><li>先修改turn的那个线程把turn改为了对方, 但是后面另一个线程会把自己的turn改回自己.</li><li>turn决定了到底谁进入临界区, 手快️, 手慢️.</li></ol><p>感性理解正确性:</p><ol><li>如果两个线程都想访问临界区, 但是一个线程A比较快, 把turn改为了对方:<ol><li>如果另一个线程B还没有亮起自己的标志, 那A就直接进了, 一会B亮标志再改turn的时候会因为turn被自己改成了A而阻塞, 直到A退出临界区, 灭掉了A的标志.</li><li>如果另一个线程已经亮起了自己的标志, 那A会阻塞到B把turn改为A之后, A进入临界区, B同样会被阻塞.</li></ol></li><li>也就是说, 因为大家都会把turn改为对方, 所以大家都会阻塞直到所有人都改了turn, 这时候就根据turn是谁决定谁进入临界区.</li></ol><p>一些思考:</p><ol><li>能不能先改turn, 再亮标志?<ol><li>肯定不行, 假如A先把turn改成了B, 然后因为这时候A没有亮标志, 所以B可以直接改turn为A+亮标志+进入临界区, 这时候A因为看到turn为自己, 也可以直接进入临界区, 就寄了.</li></ol></li></ol><p>Peterson算法属于比较一般的互斥算法, 只要内存模型是顺序一致的(Sequential Consistent), 就可以实现两个线程的互斥, 不需要任何复杂原子性的操作. 类似的算法还有dekker, 都比较复杂, 现代操作系统一般可以依赖于硬件实现的原子操作来简化互斥.</p><p>为了防止编译器和处理器在不同级别上的乱序优化, 可能需要在某些地方加不同级别的Barrier.</p><h2 id="Model-Checking"><a href="https://honoka.tech/2022/08/21/mutex/#Model-Checking" class="headerlink" title="Model Checking"></a>Model Checking</h2><p>使用工具来检验模型的正确性!</p><p>其实就遍历多个线程状态机转移的每一种情况, bfs枚举.</p><p>可以使用python来模拟这个操作, 每一行语句后面加一个yield, 每一个线程包装成一个generator, 一次__next__() 就相当于一个线程执行了一步, 每一行都相当于一个原子操作.</p><p>现代软件自动化测试工具会加很多优化, 比如如果两个线程的某几步涉及到的内存完全不相关, 那他们这几步的顺序是无所谓的…诸如此类.</p><p>还可以用来检查filesystem的正确性, 和其他内存模型下的算法正确性…</p><h2 id="锁"><a href="https://honoka.tech/2022/08/21/mutex/#%E9%94%81" class="headerlink" title="锁"></a>锁</h2><p>但是Peterson的假设太弱了, 没有任何复杂的原子操作, 只有load和store.</p><p>自旋锁是加了一个原子指令: lock.</p><p>互斥锁是增加了操作系统作为调度者.</p><p>Futex是结合了自旋锁和互斥锁的优点, 目前使用的Mutex很多都是Futex.</p><h3 id="自旋锁-Spinning-Lock"><a href="https://honoka.tech/2022/08/21/mutex/#%E8%87%AA%E6%97%8B%E9%94%81-Spinning-Lock" class="headerlink" title="自旋锁 (Spinning Lock)"></a>自旋锁 (Spinning Lock)</h3><p>lock xchg %1, %2. 原子性的交换%1和%2.</p><p>实际上这就是一个load+store:</p><ol><li>load了%1到%2.</li><li>Store了%2到%1.</li></ol><p>如果一个有共享内存a, 0代表未上锁, 1代表上锁.</p><p>那么让b为1, xchg a, b, 检查a</p><ol><li>如果b是1, 说明本来a本来就是1, 说明已经有人上过锁了, 返回xchg重试.</li><li>如果b是0, 说明本来a是0, 没有人上锁, 现在我们把a换成了1, 我们可以安心访问临界资源了.</li><li>从临界区退出后, 把a改回0.</li></ol><h4 id="自旋锁的缺陷"><a href="https://honoka.tech/2022/08/21/mutex/#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E7%BC%BA%E9%99%B7" class="headerlink" title="自旋锁的缺陷"></a>自旋锁的缺陷</h4><ol><li>访问共享变量的自旋会出发多处理器之间的同步, 拖累性能.</li><li>一个线程抢占到锁之后, 其他处理器都在空转!</li><li>获得自旋锁的线程可能会被操作系统切换出去! 其他线程啥也别想干.</li></ol><h4 id="自旋锁的使用场景"><a href="https://honoka.tech/2022/08/21/mutex/#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" class="headerlink" title="自旋锁的使用场景"></a>自旋锁的使用场景</h4><ol><li>临界区几乎不拥堵, 不太会出现多个线程抢占的情况.</li><li>持有自旋锁的时候可以禁止流切换, 但是一般的程序也没这个权利.</li></ol><p>所以基本只有在操作系统内核中才会使用自旋锁:</p><ol><li>操作系统可以关闭中断和抢占, 保证锁的持有者很快就会释放锁</li></ol><p>但是即使这样也很难用好自旋锁.</p><h3 id="Lock指令"><a href="https://honoka.tech/2022/08/21/mutex/#Lock%E6%8C%87%E4%BB%A4" class="headerlink" title="Lock指令"></a>Lock指令</h3><h4 id="x86的lock"><a href="https://honoka.tech/2022/08/21/mutex/#x86%E7%9A%84lock" class="headerlink" title="x86的lock"></a>x86的lock</h4><p>在三十年前的80486时期就已经支持双路处理器, 支持lock了.</p><p>lock指令会保证, 在lock之前的所有store都已经写入内存.</p><p>在早期缓存是所有处理器共享的时候, 一个处理器执行lock指令时, 会把总线锁上, 这样其他处理就不会干扰他的原子操作.</p><p>但是现代处理器内部就有缓存, x86就要在L1级别的cache上保证一致性. 所有的L1 Cache都是串起来的, 一个处理器执行了原子性更改内存的操作, 需要更改所有出现这个块的缓存.</p><p>这也是x86背负的巨大历史包袱之一.</p><h4 id="RISC-V的另一种lock实现"><a href="https://honoka.tech/2022/08/21/mutex/#RISC-V%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8Dlock%E5%AE%9E%E7%8E%B0" class="headerlink" title="RISC-V的另一种lock实现"></a>RISC-V的另一种lock实现</h4><p>常见的原子操作基本都分为三步:</p><ol><li>load.</li><li>exec, 即处理器自己在进行计算.</li><li>store.</li></ol><p>RISC-V认为exec操作可以多次进行, 影响不大, 所以使用了Load-Reserved/Store-Conditional策略:</p><ol><li>在执行原子操作前, 把需要影响到的内存打上Reserved标记.</li><li>如果计算期间有中断, 或者有其他处理器写入, 标记都会清除.</li><li>store时判断是否有标记, 没有标记就重试.</li></ol><h3 id="互斥锁-Mutex"><a href="https://honoka.tech/2022/08/21/mutex/#%E4%BA%92%E6%96%A5%E9%94%81-Mutex" class="headerlink" title="互斥锁 (Mutex)"></a>互斥锁 (Mutex)</h3><p>互斥锁可以让没抢到锁的线程被操作系统阻塞, 操作系统可以去执行其他线程.</p><p>当然, 一般的用户程序也没这个权利, 所以互斥锁需要通过系统调用进入内核.</p><ol><li><strong>syscall(SYSCALL_lock, &amp;lk);</strong> 尝试获取锁lk, 如果失败, 进入阻塞.</li><li><strong>syscall(SYSCALL_unlock, &amp;lk);</strong> 释放lk, 唤醒其他因为lk而阻塞的线程.</li></ol><p>操作系统的操作:</p><ol><li>先获取锁的线程, 得到锁, 操作系统让lk=1.</li><li>后获取锁的线程, 进入阻塞队列.</li><li>得到锁的线程释放锁后, 唤醒阻塞队列中的一个线程执行.</li><li>如果阻塞队列为空, lk=0;</li></ol><p>操作系统使用自旋锁来保证自己的操作是原子的.</p><h3 id="Futex"><a href="https://honoka.tech/2022/08/21/mutex/#Futex" class="headerlink" title="Futex"></a>Futex</h3><p>自旋锁的两种情况:</p><ol><li>更快的fast path: xchg成功, 进入临界区, 开销很小.</li><li>更慢的slow path: xchg失败, 浪费资源自旋.</li></ol><p>Mutex的两种情况:</p><ol><li>更快的slow path: 上锁失败, 直接阻塞.</li><li>更慢的fast path: 无论如何都要进入内核.</li></ol><p>Fast Userspace muTexes (Futex) 的折衷:</p><ol><li>Fast path: 一条原子指令, 上锁成功直接返回.</li><li>Slow path: 上锁失败, 阻塞.</li></ol><p>Linux大范围地使用Futex代替Mutex.</p><p>在FreeBSD, Linux中的Golang里的sync.Mutex, 实际上也是Futex.</p></body></html>