<html><head></head><body><blockquote><p>操作系统的本质：一个程序，用于管理硬件资源供其他程序调用</p></blockquote><p>那问题就到了程序本身：程序应该如何定义？这引出了程序的状态机模型：</p><h2 id="状态机"><a href="https://xeonds.github.io/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/#%E7%8A%B6%E6%80%81%E6%9C%BA" class="headerlink" title="状态机"></a>状态机</h2><p>这东西我们在数电中接触过，硬件基础就是一堆触发器（RS、JK等）。<strong>状态</strong>就是寄存器保存的值，初始状态即寄存器初始值，<strong>迁移</strong>就是组合逻辑电路计算寄存器下一周期的值。</p><p>下面是一个寄存器的模拟程序。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REGS_FOREACH(_) _(X) _(Y) </span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> RUN_LOGIC X1 = !X &amp;&amp; Y; \ </span></span><br/><span class="line">  Y1 = !X &amp;&amp; !Y; </span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE(X) static int X, X##1; </span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> UPDATE(X) X = X##1; </span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(X) printf(#X <span class="string">&#34; = %d; &#34;</span>, X); </span></span><br/><span class="line"></span><br/><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> { </span><br/><span class="line">REGS_FOREACH(DEFINE); </span><br/><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) { <span class="comment">// clock </span></span><br/><span class="line">RUN_LOGIC; </span><br/><span class="line">REGS_FOREACH(PRINT); </span><br/><span class="line">REGS_FOREACH(UPDATE); </span><br/><span class="line"><span class="built_in">putchar</span>(<span class="string">&#39;\n&#39;</span>); </span><br/><span class="line">sleep(<span class="number">1</span>); </span><br/><span class="line">} </span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><h2 id="程序的定义"><a href="https://xeonds.github.io/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9A%E4%B9%89" class="headerlink" title="程序的定义"></a>程序的定义</h2><h3 id="源码视角"><a href="https://xeonds.github.io/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/#%E6%BA%90%E7%A0%81%E8%A7%86%E8%A7%92" class="headerlink" title="源码视角"></a>源码视角</h3><p>程序就是状态机。对于C程序而言，它的状态机模型如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line">状态=栈帧+全局变量</span><br/><span class="line">初始状态=main</span><br/><span class="line">迁移=执行栈顶的语句并转到下一条指令</span><br/><span class="line">函数调用=入栈</span><br/><span class="line">函数返回=出栈</span><br/></pre></td></tr></tbody></table></figure><p>这定义有很多应用，比如将任何递归程序就地转为非递归。虽然实际上递归就是这么实现的（一层递归建立一层函数栈、跳转地址压栈）。例如，下面就是手写函数栈展开递归：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br/><span class="line">  <span class="type">int</span> pc, n;</span><br/><span class="line">  <span class="type">char</span> from, to, via;</span><br/><span class="line">} Frame;</span><br/><span class="line"></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> call(...) ({ *(++top) = (Frame) { .pc = 0, __VA_ARGS__ }; })</span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> ret()     ({ top--; })</span></span><br/><span class="line"><span class="meta">#<span class="keyword">define</span> goto(loc) ({ f-&gt;pc = (loc) - 1; }</span></span><br/><span class="line">  </span><br/><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> from, <span class="type">char</span> to, <span class="type">char</span> via)</span> {</span><br/><span class="line">  Frame stk[<span class="number">64</span>], *top = stk - <span class="number">1</span>;</span><br/><span class="line">  call(n, from, to, via);</span><br/><span class="line">  <span class="keyword">for</span> (Frame *f; (f = top) &gt;= stk; f-&gt;pc++) {</span><br/><span class="line">    <span class="keyword">switch</span> (f-&gt;pc) {</span><br/><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">if</span> (f-&gt;n == <span class="number">1</span>) { <span class="built_in">printf</span>(<span class="string">&#34;%c -&gt; %c\n&#34;</span>, f-&gt;from, f-&gt;to); <span class="keyword">goto</span>(<span class="number">4</span>); } <span class="keyword">break</span>;</span><br/><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;from, f-&gt;via, f-&gt;to);   <span class="keyword">break</span>;</span><br/><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: call(       <span class="number">1</span>, f-&gt;from, f-&gt;to,  f-&gt;via);  <span class="keyword">break</span>;</span><br/><span class="line">      <span class="keyword">case</span> <span class="number">3</span>: call(f-&gt;n - <span class="number">1</span>, f-&gt;via,  f-&gt;to,  f-&gt;from); <span class="keyword">break</span>;</span><br/><span class="line">      <span class="keyword">case</span> <span class="number">4</span>: ret();                                    <span class="keyword">break</span>;</span><br/><span class="line">      <span class="keyword">default</span>: assert(<span class="number">0</span>);</span><br/><span class="line">    }</span><br/><span class="line">  }</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><h3 id="二进制视角"><a href="https://xeonds.github.io/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A7%86%E8%A7%92" class="headerlink" title="二进制视角"></a>二进制视角</h3><p>实际上就是汇编视角。汇编程序分为几个段：数据段、代码段和栈段。加载程序就是加载初始状态，状态转移就是改变寄存器的值，转移方式就是执行指令。</p><p>这两个视角都可以用<code>gdb</code>来查看。</p><p>但是，操作系统又不是普通程序。因为操作系统不光处理计算任务，还需要能够暂停、退出程序等等。</p><p>在Linux中，有一条叫做<code>systemcall</code>（系统调用）的指令。它不负责计算，它把当前进程的状态交给操作系统，也就是允许操作系统任意更改程序。这使得进程可以和操作系统中的其他对象交互。</p><p>也就是说，对于程序而言，操作系统就是一个程序。参数就是应用程序本身的状态，输出就是程序要访问的资源。C程序main函数最后的<code>return;</code>就是这样的，它实质上是借助了<code>syscall()</code>，将程序状态变为某特定状态，再交给系统去处理。这就好比准备好要传递的参数，然后去调用函数一样。</p><p>回到主题。从二进制/操作系统的视角看来，<strong>程序是一个不停计算，并会穿插执行systemcall的状态机</strong>。</p><h2 id="什么是编译器"><a href="https://xeonds.github.io/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8" class="headerlink" title="什么是编译器"></a>什么是编译器</h2><p>编译器将源代码编译为二进制程序。从汇编状态机/C程序状态机的视角来看，实际上就是将后者翻译成了前者。编译（优化）的正确性（Soundness）就是在确保二者的<strong>可观测行为</strong>完全一致。</p><p>而关于编译器优化，我们可以使用<code>compiler barrier</code>来阻止优化：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> g;</span><br/><span class="line"></span><br/><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span>{</span><br/><span class="line">g++;</span><br/><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&#34;nop&#34;</span> : : <span class="string">&#34;r(x)&#34;</span> : <span class="string">&#34;memory&#34;</span>)</span>; <span class="comment">// compiler barrier</span></span><br/><span class="line">g++;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>上面的代码借助objdump查看反编译代码，可以看出，这两条<code>g++</code>并没有被<code>-O2</code>编译优化。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line">$ gcc -O2 -c a.c &amp;&amp; objdump -d a.o</span><br/><span class="line"></span><br/><span class="line">a.o:     file format elf64-x86-64</span><br/><span class="line"></span><br/><span class="line"></span><br/><span class="line">Disassembly of section .text:</span><br/><span class="line"></span><br/><span class="line">0000000000000000 &lt;foo&gt;:</span><br/><span class="line">   0:   f3 0f 1e fa             endbr64</span><br/><span class="line">   4:   83 05 00 00 00 00 01    addl   <span class="variable">$0x1</span>,0x0(%rip)        <span class="comment"># b &lt;foo+0xb&gt;</span></span><br/><span class="line">   b:   90                      nop</span><br/><span class="line">   c:   83 05 00 00 00 00 01    addl   <span class="variable">$0x1</span>,0x0(%rip)        <span class="comment"># 13 &lt;foo+0x13&gt;</span></span><br/><span class="line">  13:   c3                      retq</span><br/></pre></td></tr></tbody></table></figure><p>除此之外，还有一种更强的barrier：<code>__sync_synchronize();</code></p><h3 id="观察编译器"><a href="https://xeonds.github.io/2023/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8/#%E8%A7%82%E5%AF%9F%E7%BC%96%E8%AF%91%E5%99%A8" class="headerlink" title="观察编译器"></a>观察编译器</h3><p>使用<code>strace</code>，我们可以看到一个程序所有的系统调用。借助下面几个工具的组合，我们可以看到gcc如何编译程序：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br/><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br/><span class="line"></span><br/><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>{</span><br/><span class="line"><span class="built_in">printf</span>(<span class="string">&#34;Hello, OS!&#34;</span>);</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>保存上面的文件后，执行下面的指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">strace -f gcc a.c |&amp; vim -</span><br/></pre></td></tr></tbody></table></figure><p>我们可以在Vim中看到下面的输出</p><p>![[Pasted image 20230128215947.png]]</p><p>稍微修改后（<code>:%!grep execve</code>留下系统调用的行，<code>:%!grep -v ENOENT</code>删除失败的行，<code>:%s/, /\r  /g</code>将参数换行显示，提高结果可读性），可以分析得到下面的结果</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/></pre></td><td class="code"><pre><span class="line"> 1 execve(<span class="string">&#34;/usr/bin/gcc&#34;</span></span><br/><span class="line"> 2   [<span class="string">&#34;gcc&#34;</span></span><br/><span class="line"> 3   <span class="string">&#34;a.c&#34;</span>]</span><br/><span class="line"> 4   0x7ffd181ca900 /* 30 vars */) = 0</span><br/><span class="line"> 5 [pid   212] execve(<span class="string">&#34;/usr/lib/gcc/x86_64-linux-gnu/9/cc1&#34;</span></span><br/><span class="line"> 6   [<span class="string">&#34;/usr/lib/gcc/x86_64-linux-gnu/9/&#34;</span>...</span><br/><span class="line"> 7   <span class="string">&#34;-quiet&#34;</span></span><br/><span class="line"> 8   <span class="string">&#34;-imultiarch&#34;</span></span><br/><span class="line"> 9   <span class="string">&#34;x86_64-linux-gnu&#34;</span></span><br/><span class="line">10   <span class="string">&#34;a.c&#34;</span></span><br/><span class="line">11   <span class="string">&#34;-quiet&#34;</span></span><br/><span class="line">12   <span class="string">&#34;-dumpbase&#34;</span></span><br/><span class="line">13   <span class="string">&#34;a.c&#34;</span></span><br/><span class="line">14   <span class="string">&#34;-mtune=generic&#34;</span></span><br/><span class="line">15   <span class="string">&#34;-march=x86-64&#34;</span></span><br/><span class="line">16   <span class="string">&#34;-auxbase&#34;</span></span><br/><span class="line">17   <span class="string">&#34;a&#34;</span></span><br/><span class="line">18   <span class="string">&#34;-fasynchronous-unwind-tables&#34;</span></span><br/><span class="line">19   <span class="string">&#34;-fstack-protector-strong&#34;</span></span><br/><span class="line">20   <span class="string">&#34;-Wformat&#34;</span></span><br/><span class="line">21   <span class="string">&#34;-Wformat-security&#34;</span></span><br/><span class="line">22   <span class="string">&#34;-fstack-clash-protection&#34;</span></span><br/><span class="line">23   <span class="string">&#34;-fcf-protection&#34;</span></span><br/><span class="line">24   <span class="string">&#34;-o&#34;</span></span><br/><span class="line">25   <span class="string">&#34;/tmp/ccf8oz38.s&#34;</span>]</span><br/><span class="line">26   0x251bbd0 /* 35 vars */ &lt;unfinished ...&gt;</span><br/><span class="line">...</span><br/></pre></td></tr></tbody></table></figure><p>上面就是<code>gcc</code>编译这个程序的全流程，以及全部的参数。这些系统调用都能看得到。也就证明了前面的结论：程序=系统调用+计算。我们写的算法题就几乎属于纯计算（只有最后的<code>return 0;</code>算个系统调用），平时使用的各种程序就属于系统调用+计算的类型。</p></body></html>