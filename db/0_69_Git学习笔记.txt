<html><head></head><body><h2 id="安装"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%AE%89%E8%A3%85" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">sudo apt install git -y     <span class="comment"># ubuntu, etc.</span></span><br/><span class="line">sudo pacman -S git          <span class="comment"># arch linux</span></span><br/></pre></td></tr></tbody></table></figure><p>Windows从官网下载exe安装，一路下一步即可。</p><h2 id="配置"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E9%85%8D%E7%BD%AE" class="headerlink" title="配置"></a>配置</h2><p>Git的配置文件有两种，全局配置文件，和相对于单个仓库而言的局部配置文件。前者应用于该系统中所有仓库，而后者应用于某个仓库。二者存在冲突项时，以后者优先级为更高。</p><p>全局配置文件存在于Linux的<code>~/.gitconfig</code>，或者是Windows的用户目录下的<code>.gitconfig</code>。修改的配置都会储存在这个文件中。而局部配置文件存在于仓库的<code>.git/config</code>中，使用<code>git config</code>编辑，一般不推荐直接编辑。</p><p>在Linux中，输入<code>git config</code>后就可以用Tab补全来看到所有可选的选项了。此时修改的，是局部配置；加上<code>--global</code>参数后，修改的就是全局配置。</p><ul><li>设置用户名和邮箱</li></ul><p>配置第一步，先设置用户名和邮箱。这是创建提交的重要凭据，相当于你给作品的签名。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">git config --global user.name   <span class="string">&#34;your name&#34;</span></span><br/><span class="line">git config --global user.email  <span class="string">&#34;your email&#34;</span></span><br/></pre></td></tr></tbody></table></figure><ul><li>修改默认编辑器</li></ul><p>惯用Vim，感觉默认的Nano用不习惯，所以果断换回Vim：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">git config --global core.editor vim</span><br/></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br/><span class="line"><span class="comment"># 修改为如下内容</span></span><br/><span class="line">[core]</span><br/><span class="line">    editor=vim</span><br/></pre></td></tr></tbody></table></figure><ul><li>禁用Fast-Forward</li></ul><p>关于这是什么和为什么禁用的问题请看后文。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">git config --global merge.ff <span class="literal">false</span></span><br/></pre></td></tr></tbody></table></figure><h2 id="入门"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%85%A5%E9%97%A8" class="headerlink" title="入门"></a>入门</h2><blockquote><p>推荐去看《Pro Git》系统学习。</p></blockquote><p>git是重要且强大的版本控制工具。版本控制就相当于Word的历史记录功能，不过远比那强大和可靠。你可以在任何时候，为你当前的修改创建一个<code>commit</code>，它会记录你的仓库中所有文件相对于上个时间点的所有更改记录。</p><p>当项目规格急剧增大时，使用版本控制系统(VCS)就是必然的选择：多分支并行开发，代码合并，进度追踪等等，都是保持开发流程井然有序的重要方法。</p><p>如果用剧本走向来比喻git，那么git能做到的就是让你能同时尝试所有世界线，并把你喜欢的结局组合到一起。</p><h2 id="功能"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%8A%9F%E8%83%BD" class="headerlink" title="功能"></a>功能</h2><p>基本上，只要掌握<code>add</code>, <code>commit</code>, <code>push</code>, <code>pull</code>, <code>merge</code>就可以应付日常使用了。对于一些常见问题，使用<code>git help</code>或者在网上寻找答案都是不错的选择。</p><p>在介绍功能之前，你可以先去看看Pro Git前几章对Git模型的介绍，包括各种状态的转换，几个空间等。这里简单的介绍下：</p><p>Git（大体上）有三个区：首先是工作区，它的范围是你文件夹里所有除了<code>.git</code>目录以外的所有文件；其次是暂存区，你更改后使用<code>git add</code>暂存的文件都存储在这里。最后一个区是长期存储区，它保存着你的每一个文件，以及对它的每一次修改历史的原始版本。后两个区都位于<code>.git</code>目录中。也就是说，只要<code>.git</code>目录还在，那么即使你删了仓库里边所有的东西，也能用git恢复所有删除的文件，甚至是你以前的任何一个状态上——就好比玩Gal的时候随时跳转到世界线上的任意一个历史节点。</p><p>文件在这三个区域里，也会有不同的状态：在工作区中的文件会呈现出“未跟踪”，或者“已修改”的状态，对它们使用<code>git add filename</code>就能把它们送到暂存区，转变为暂存状态。此时<strong>对这些文件做出的任何修改都可以从暂存区恢复</strong>，比如不小心删了一段代码又撤销不了，就可以从暂存区恢复这个文件。而暂存区的文件，一旦取消暂存状态，你的这些更改也会跟着消失。这时候，你要是不小心删除了什么还没法撤销的话，就是真丢了。而此时，如果你想把这次更改从暂存区长久保存，就可以使用<code>git commit</code>来“提交”你在暂存区存放的所有文件，它们会被放到长期存储区。而在这之前，git会要求你输入一个提交消息。这个消息是强制的，不能输入空白的消息。虽然有时候麻烦，但是对于以后的版本管理是很便利的：你可以想起来这次提交做了什么修改。输入提交信息后，你的修改就并入长期存储区了。这个时候，你的代码基本上就很安全了。使用<code>git log</code>就能看到你的每一个提交记录。</p><p>除了上面说的那些，还有一个最重要的功能没有提到：git分支。git的提交历史就像是一个复杂树状链表结构，每一个提交都指向它的父结点。当你创建提交时，其实你就指定了它的父结点：也就是你这次更改的状态，它就是你的父节点。因此，你可以选择一个节点，将它作为你的父结点，并将你的改动提交的父结点指向它。而如果你指向的父结点已经有了一个子结点，那么这就会创建一个分支（branch），这个分支一般以一个名字标识，范围是从分叉点到这个分支的最新的一次提交记录。这就好比玩Gal时，玩到一半时，回溯到前面的一个结点，选择了另一个选项，从而开启了另一条世界线一样。而与Galgame不同的是，你可以将两个结局“合二为一”，合并为一个新的结局，并开始一段新的可能。基于提交的Git，就能做到将另一个分支的最新提交结点，和当前所在的结点合并，从而产生一个新的结点。一般而言，这个结点会被看作是属于当前分支的：例如，把develop分支合并到当前所在的master分支，产生的用于merge的提交记录就属于master分支。这样的分支模型是git设计的最大魅力之一。</p><p>基于git的分支系统，就诞生了使用分支进行开发的最佳实践，也就是git工作流。具体而言就是约定了几个用来完成特定工作的git分支，并严格规定了分支之间的操作准则。</p><h3 id="Commit"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>这是git的基础操作之一，在使用之前，先使用<code>git add</code>将要提交的文件加入暂存区。最简单的用法就是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">git commit</span><br/></pre></td></tr></tbody></table></figure><p>然后等待git弹出提交消息编辑器，输入提交消息，完成提交。如果输入了空白消息，git就会取消提交。</p><h3 id="Push-amp-Pull"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Push-amp-Pull" class="headerlink" title="Push &amp; Pull"></a>Push &amp; Pull</h3><p>推送代码到远程仓库/拉取远程仓库到本地。用于同步本地和云端的代码更改。运行时一般不加啥参数，就是如果目标已经有了更改，可能得加上<code>--merge</code>或者<code>--rebase</code>来处理冲突。</p><h3 id="GitHub-Pull-Request-PR"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#GitHub-Pull-Request-PR" class="headerlink" title="GitHub Pull Request(PR)"></a>GitHub Pull Request(PR)</h3><p>虽然不属于git的基本操作但还是提一嘴。这是GitHub的一个操作，用于将别的分支合并到一个特定的分支上。它的使用场景通常如下：你想贡献代码给一个开源项目，就先在GitHub上fork他们的仓库，随后在其中完成你的更改，创建提交。最后，发起一个Pull Request，请求目标仓库拉取你仓库的最新提交到它自身。这种合并是可以跨越仓库的，而前提是它们之间得是fork的关系：其他仓库都是这个仓库的<code>fork</code>。满足这个条件之后，就可以在GitHub上新建一个PR，来通过这样的方式贡献你的代码了。</p><p>像Linux这样的重量级开源自由软件，就是无数人通过PR之类的操作慢慢构建起来的。甚至现在打开<a href="https://github.com/torvalds/linux">这个页面</a>还能看到Linus天天在Merge PR（笑死</p><h3 id="Merge"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Merge" class="headerlink" title="Merge"></a>Merge</h3><p>基本用法：假设当前是master分支，你想要将dev分支合并进来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">git merge dev</span><br/></pre></td></tr></tbody></table></figure><p>如果没有冲突的话，合并就会顺利完成；否则，你需要在合并编辑器里手动处理那些冲突，然后再提交，完成合并。</p><h4 id="Fast-Forward"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Fast-Forward" class="headerlink" title="Fast-Forward"></a>Fast-Forward</h4><p>就和它的名字一样，它是用于快速跟进的合并功能。一般的merge会生车工一个merge提交，而fast-forward只是让主分支的HEAD指向被merge的分支的HEAD。这样做的好处显而易见：开发进度跟进非常容易，只需要移动一个指针即可，并且节省了git的空间占用开销。缺点却很是问题：当被合并的分支删除后，<strong>git的树结构就会被“捋平”</strong>——那些fast-forward的点上没有merge生成的commit节点，所有fast-forward之间的连线自然就相当于“断开”的。</p><p>因此，Merge时，尽量禁用fast-forward，否则一旦删除分支，就无法再看到那个分支上到底干了什么。这对于代码问题追踪是很不利的因素。因此在开发中，应当尽量禁用fast-forward。</p><p>全局禁用的指令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">git config --global --add merge.ff <span class="literal">false</span></span><br/></pre></td></tr></tbody></table></figure><h3 id="Branch"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Branch" class="headerlink" title="Branch"></a>Branch</h3><h3 id="Log"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Log" class="headerlink" title="Log"></a>Log</h3><h3 id="Tag"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#Tag" class="headerlink" title="Tag"></a>Tag</h3><p>Git tag是一种用于在Git仓库中标记特定版本的方法。它通常被用来标记重要的里程碑版本或发布版本，以便于在后续的开发或维护过程中快速定位和回溯到这些版本。</p><p>Git tag可以被创建并附加到任何一个Git commit对象上，而且可以添加任意多个标签，每个标签都可以添加一个描述信息。</p><p>在Git中，有两种类型的tag: lightweight tag和annotated tag。</p><p>轻量级标签（Lightweight tag）只是一个指向某个commit的引用，相当于一个不带附加信息的快照。而附注标签（Annotated tag）则是一个独立的Git对象，它除了包含指向某个commit的引用外，还可以包含标签作者、标签日期、描述信息等元数据。附注标签更适合用于发布版本和重要的里程碑。</p><p>要创建一个tag，可以使用<code>git tag</code>命令，例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">git tag v1.0.0     <span class="comment"># 创建一个名为v1.0.0的轻量级标签</span></span><br/><span class="line">git tag -a v1.0.0 -m <span class="string">&#34;Release version 1.0.0&#34;</span>    <span class="comment"># 创建一个名为v1.0.0的附注标签，同时添加描述信息</span></span><br/></pre></td></tr></tbody></table></figure><p>要将标签推送到远程仓库，可以使用<code>git push</code>命令，例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">git push origin v1.0.0   <span class="comment"># 将名为v1.0.0的标签推送到远程仓库</span></span><br/></pre></td></tr></tbody></table></figure><p>要查看所有标签，可以使用<code>git tag</code>命令，例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">git tag        <span class="comment"># 列出所有标签</span></span><br/><span class="line">git tag -l <span class="string">&#34;v1.*&#34;</span>    <span class="comment"># 列出所有以v1开头的标签</span></span><br/></pre></td></tr></tbody></table></figure><h2 id="常见问题"><a href="https://xeonds.github.io/2022/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>Cannot do a soft reset in the middle of a merge</li></ul><p>错误原因很显然，就是我们在合并分支时想要撤销上次提交。我通常是因为在一个设备上commit&amp;push了一些代码，而在另一台设备上已经commit了一些代码，随后打算先pull同步一下再push上去。这时就会提示将pull下来的代码merge到本地仓库中，这时候我一般会merge&amp;push，但是有时候发现不小心把另一个分支的给pull到当前分支了，这时候就需要取消错误的pull操作。然而此时已经进入了merge状态，所以只能先退出这状态再重新正确地同步仓库。</p><p>首先，用<code>git stash</code>保存当前的更改，然后<code>git reset --merge</code>退出合并状态。这时再重新正确拉取代码即可。</p><ul><li>Linux平台鉴权失败</li></ul><p>这是因为GitHub现在已经禁用了Git Cli的登录方式。因此我们需要重新配置其他的凭据管理器。比如我使用了<code>git-credential-oauth</code>，这样我就可以跳转到浏览器里登录认证GitHub凭据。配置方法很简单：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> credential.helper</span><br/><span class="line">git-credential-oauth configure</span><br/></pre></td></tr></tbody></table></figure><p>完成后，再执行push时，就会弹出浏览器窗口提示授权GitHub帐号了。</p><ul><li>文件上传和下载后，文件名大小写变化</li></ul><p>git默认设置中，对于文件名的设置是<strong>大小写不敏感</strong>。因此如果有必要的话，还是把这个设为false来解决问题吧：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先获取当前设置状态，为true则执行下一条指令</span></span><br/><span class="line">git config --get core.ignorecase </span><br/><span class="line"><span class="comment"># 设置不忽略大小写</span></span><br/><span class="line">git config core.ignorecase <span class="literal">false</span></span><br/></pre></td></tr></tbody></table></figure><ul><li>Git Pull –Rebase vs –Merge</li></ul><p>假设A和B同时克隆了一个仓库，并各自完成了一些修改。此时A想要推送自己的提交，却发现B已经推送了自己的提交。此时应该怎么做呢？</p><p>两种方法，首先是merge。拉取的时候加上<code>--merge</code>选项，会自动合并你们的提交。如果有冲突，就会在你的合并编辑器里展示出来，待你修改完成后，以一个合并提交的方式提交上去。</p><p>其次是rebase。它大致相当于“移花接木“：把你本地做的提交拼接到拉取下来的更改后边。这样产生的提交记录更加简洁。用法就是拉取时加上<code>--rebase</code>参数。</p><p>两种方式的选择取决于你们项目的开发规范，以及你的喜好。如果偏爱简洁，你可能更喜欢rebase；如果你追求commit的尽可能详尽，那么merge可能更适合你。</p><ul><li>Git拉取submodule</li></ul><p>编译thtk的时候发现submodule没拉取，记录一下这玩意怎么拉）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br/></pre></td></tr></tbody></table></figure></body></html>