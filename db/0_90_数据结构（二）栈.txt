<html><head></head><body><h2 id="0x01-简介"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/#0x01-%E7%AE%80%E4%BB%8B" class="headerlink" title="0x01.简介"></a>0x01.简介</h2><p>栈（stack）是一种数据结构。它遵循的原则是FILO（First In Last Out），也就是先进后出。类比现实的例子，就是子弹上膛，最先压进去弹夹的子弹一般是最后一个被打出去的。</p><h2 id="0x02-性质"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/#0x02-%E6%80%A7%E8%B4%A8" class="headerlink" title="0x02.性质"></a>0x02.性质</h2><h3 id="反转队列"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/#%E5%8F%8D%E8%BD%AC%E9%98%9F%E5%88%97" class="headerlink" title="反转队列"></a>反转队列</h3><p>将一个队列的元素压入栈，再依次出栈，就能得到原队列的逆序队列。所以栈可以用于产生逆序队列。</p><h3 id="出栈顺序"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/#%E5%87%BA%E6%A0%88%E9%A1%BA%E5%BA%8F" class="headerlink" title="出栈顺序"></a>出栈顺序</h3><p>一个有n个元素的队列，按照一定顺序出入栈，得到另一个顺序的列表。试问顺序是否可以取到全排列$A_n^n$呢？</p><p>显然不能。</p><p>要得到一个新队列，那必然要进行$2n$次操作，即$n$次入栈和$n$次出栈。而这些操作共有$C_{2n}^n=\frac{(2n)!}{n!^2}$种组合，因而生成的新队列并没有$n!$那么多。</p><p>那么，判断队列是否可由栈生成自然也是重点。最简单的办法就是在草稿纸上模拟一个栈，从生成的新队列的第一个元素开始，反推出入栈操作即可。</p><p>将入栈和出栈记作I和O。我们来分析一个例子，比如<code>1 3 5 4 2</code>，遇到1我们就可以推得操作是IO，3的话，因为前面有2，所以得先入2才能入3，所以是IIO。此时栈中有元素<code>2</code>。接下来的5和3同理，操作是IIO，到此为止我们完成了5次I，3次O，栈中还有<code>4 2</code>，所以我们需要OO，得到最终的队列：<code>1 3 5 4 2</code>。</p><p>如何用程序实现这种判断呢？可以先生成一个大小为$n!$的<code>map&lt;队列，bool&gt;</code>，随后根据上面的数学过程穷举结果，并将结果对应的<code>index</code>标记为<code>true</code>然后用查表法得到结果。</p><p>当然，如果懒得写生成器，也可以用图灵机完成判断。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">data</span>):</span><br/><span class="line">    I,cnt=<span class="number">0</span>,<span class="built_in">len</span>(data)</span><br/><span class="line">    a,b=[i+<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cnt)],[]</span><br/><span class="line">    </span><br/><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br/><span class="line">        <span class="keyword">while</span> TRUE:</span><br/><span class="line">            <span class="keyword">if</span> I==cnt: <span class="keyword">break</span></span><br/><span class="line">            b.push(tmp=a.pop_front)</span><br/><span class="line">            I+=<span class="number">1</span></span><br/><span class="line">            <span class="keyword">if</span> tmp==i: <span class="keyword">break</span></span><br/><span class="line">        <span class="keyword">if</span> b.pop!=i: <span class="keyword">return</span> FALSE</span><br/><span class="line">    <span class="keyword">return</span> TRUE</span><br/></pre></td></tr></tbody></table></figure><p>这程序模拟了我们上面的手动判断步骤，通过一个队列和一个栈实现。</p><h2 id="0x03-实现"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/#0x03-%E5%AE%9E%E7%8E%B0" class="headerlink" title="0x03.实现"></a>0x03.实现</h2><p>用C语言实现。在C++中已经有STL中的stack，无需重复实现。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数据结构定义 */</span></span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br/><span class="line">    elemtype data;</span><br/><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span></span><br/><span class="line">}Node;</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stack</span>{</span></span><br/><span class="line">    Node * top;</span><br/><span class="line">    <span class="type">int</span> size;</span><br/><span class="line">}Stack;</span><br/><span class="line"></span><br/><span class="line"><span class="comment">/* 操作定义 */</span></span><br/><span class="line"><span class="type">bool</span> <span class="title function_">init</span><span class="params">(Stack * ptr)</span>;</span><br/><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(Stack * ptr, elemtype data)</span>;</span><br/><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(Stack * ptr, elemtype * data)</span>;</span><br/><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Stack * ptr)</span>;</span><br/></pre></td></tr></tbody></table></figure><h2 id="0x04-应用"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/#0x04-%E5%BA%94%E7%94%A8" class="headerlink" title="0x04.应用"></a>0x04.应用</h2><p>作为一种数据结构，由于栈LIFO的特性，它有很重要的应用。</p><p>比如利用短除法进行进制转换的时候，得到的数是从高位开始的，这种时候就适合用栈存储每一步的结果，最后直接出栈，就能得到正序的结果。</p><p>再比如括号匹配的检验。左括号一定是要和右括号匹配的，而栈中任一时刻，I操作次数一定是大于等于O操作次数，且最新的I对应最新的O。因此，利用栈，我们就能很容易检验匹配：遇到左括号就入栈，遇到右括号就出栈，如果不匹配返回<code>false</code>，最终返回<code>true</code>即可。</p><p>在二叉树的遍历中，我们也用栈进行状态记录。在图的深度优先搜索中，同样用栈记录状态。</p><p>栈不仅在数据结构上有很多应用，而且在语言和系统层面也有重要应用。</p><p>比如子程序的实现：jmp进入子程序地址之前，应该先把下一条指令的地址push到地址堆栈中，在完成子程序后再push返回主程序。高级语言中的函数调用大抵也是如此。</p><p>再比如递归程序的实现。和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</p><p>这里特别说一下栈在表达式求值的应用。</p><h3 id="表达式计算与栈"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E6%A0%88/#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E4%B8%8E%E6%A0%88" class="headerlink" title="表达式计算与栈"></a>表达式计算与栈</h3><p>栈可以把中缀表达式转换成后缀表达式，而且利用栈可以很容易地计算后缀表达式的值。</p><ol><li>后缀表达式计算</li></ol><p>过程很简单，只需要线性时间。对后缀表达式从左往右处理：遇到数字就压栈，遇到运算符就弹出两个数，把结果压栈，直到处理完成只剩一个数，即表达式的运算结果。</p><ol start="2"><li>中缀表达式转后缀表达式</li></ol><p>这需要一个栈，它用于存储操作符。遇到操作数直接输出，遇到符号就入栈。<strong>遇到右括号则出栈，直到遇到左括号为止，停止出栈</strong>。注意，括号不输出，只弹栈。</p><p>在以上条件下，遇到其他符号则弹出栈元素直到发现优先级更低的元素为止。例如，乘除优先级大于加减。</p><p>最后，输入结束后，弹栈直到空栈为止。</p></body></html>