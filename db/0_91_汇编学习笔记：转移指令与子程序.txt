<html><head></head><body><blockquote><p>[[Assembly|汇编笔记系列]]</p></blockquote><h2 id="例程"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/#%E4%BE%8B%E7%A8%8B" class="headerlink" title="例程"></a>例程</h2><p>先上例程。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br/><span class="line"></span><br/><span class="line">data segment</span><br/><span class="line">  db &#39;conversation&#39;</span><br/><span class="line">data ends</span><br/><span class="line"></span><br/><span class="line">code segment</span><br/><span class="line">  start:mov ax,data</span><br/><span class="line">        mov ds,ax</span><br/><span class="line">        mov si,0</span><br/><span class="line">        mov cx,12</span><br/><span class="line">        call capital</span><br/><span class="line">        mov ax,4c00h</span><br/><span class="line">        int 21h</span><br/><span class="line"></span><br/><span class="line">capital:and byte ptr [si],11011111b</span><br/><span class="line">        inc si</span><br/><span class="line">        loop capital</span><br/><span class="line">        ret</span><br/><span class="line">code ends</span><br/><span class="line">end start</span><br/></pre></td></tr></tbody></table></figure><p>这个程序的作用，是将data段中的字符串转化为大写。转换的原理，是大小写字母的ASCLL码的二进制的某一位不同。使用<code>and</code>和<code>or</code>就可以不使用判断语句而直接转换大小写了。</p><h2 id="简介"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/#%E7%AE%80%E4%BB%8B" class="headerlink" title="简介"></a>简介</h2><ul><li>call：用来进行标号跳转。<code>call [标号]</code>会将<code>CS:IP</code>中的IP的地址设置为指向标号所在的位置，同时将当前的CS:IP中的IP压入栈中。相当于这样：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line">push IP</span><br/><span class="line">jmp [标号和当前行的相对距离]</span><br/></pre></td></tr></tbody></table></figure><p>是不是很像C语言的goto呢？</p><ul><li>ret：用来返回程序之前的位置。ret就相当于<code>pop IP</code>。</li></ul><p>二者组合使用，就可以实现子程序的机制。其框架如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">标号:</span><br/><span class="line">    指令</span><br/><span class="line">    ret</span><br/></pre></td></tr></tbody></table></figure><p>使用子程序的框架如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br/><span class="line">code segment</span><br/><span class="line">  main: :</span><br/><span class="line">        :</span><br/><span class="line">        call sub1</span><br/><span class="line">        :</span><br/><span class="line">        :</span><br/><span class="line">        mov ax,4c00h</span><br/><span class="line">        int 21h</span><br/><span class="line"></span><br/><span class="line">  sub1: :</span><br/><span class="line">        :</span><br/><span class="line">        call sub2</span><br/><span class="line">        :</span><br/><span class="line">        :</span><br/><span class="line">        ret</span><br/><span class="line"></span><br/><span class="line">  sub2: :</span><br/><span class="line">        :</span><br/><span class="line">        :</span><br/><span class="line">        ret</span><br/><span class="line">code ends</span><br/><span class="line">end main</span><br/></pre></td></tr></tbody></table></figure><h2 id="参数传递"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92" class="headerlink" title="参数传递"></a>参数传递</h2><p>有几种思路。</p><p>第一种，利用寄存器传递参数。仅适用于参数个数少的情况。</p><p>第二种，用寄存器传递参数长度，给子程序传递参数地址。</p><p>第三种，利用栈来传递参数。</p><h2 id="寄存器冲突"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/#%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81" class="headerlink" title="寄存器冲突"></a>寄存器冲突</h2><p>有可能在主程序和子程序中，都有同样的寄存器被使用（比如循环计数寄存器CX）。此时，程序就不会按照预期来运行。</p><p>我们的解决方法是，在子程序中使用寄存器时，将所有值存储到栈里，在子程序返回前再恢复。</p><h2 id="三个子程序"><a href="https://xeonds.github.io/2021/09/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Assembly/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/#%E4%B8%89%E4%B8%AA%E5%AD%90%E7%A8%8B%E5%BA%8F" class="headerlink" title="三个子程序"></a>三个子程序</h2><p>在实验中提到了三个子程序，分别是字符串显示，解决除法溢出，数值显示。后面我会试着自己写出来。</p></body></html>