<html><head></head><body><p>最近对于Bash愈发迷恋，几乎任何会花费我超过30秒时间的任务，我都会考虑<del>打个脚先</del>写个脚本搞定。再比如说写博客，这种纯输出流就很适合Vim啊，作为一个Vim<del>批</del>必然是原教旨主义最好啊：</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230926235753.png" alt="算了截图还是用Obsidian粘吧"/></p><p>但是除了截图粘贴不方便外，还有一些比较难受的地方。在Obsidian里边我是能直接用插件的各种功能快速编写博客的，虽然在Bash终端环境下编写脚本确实更方便了，但是脚本一多，目录就乱的不能看力：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强迫症是病，得治</span></span><br/><span class="line">.</span><br/><span class="line">├── about</span><br/><span class="line">├── _archive</span><br/><span class="line">├── deploy.sh</span><br/><span class="line">├── _draft</span><br/><span class="line">├── how-much-did-i-write.sh</span><br/><span class="line">├── img</span><br/><span class="line">├── img-uri-process.sh</span><br/><span class="line">├── _inbox</span><br/><span class="line">├── links</span><br/><span class="line">├── new-post.sh</span><br/><span class="line">├── _posts</span><br/><span class="line">└── _scaffolds</span><br/><span class="line"></span><br/><span class="line">9 directories, 4 files</span><br/></pre></td></tr></tbody></table></figure><p>三个脚本，一个是统计字数的，一个是用<code>sed</code>处理图片链接的，还有一个是从模板新建博客的。每次打开目录看到这仨在中间总觉得很别扭。</p><p>除了这，还有就是用起来也不方便：前面要是不加<code>./</code>就能直接用就好了<del>懒也是病得治</del></p><p>所以，需求大概就是这样：目录级别的环境变量配置，并且支持还得够完善，不能离开目录了配置还在生效，不然脚本在其他目录跑飞了想想就恐怖。</p><h2 id="Basic-Implementation"><a href="https://mxts.jiujiuer.xyz/2023/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E5%9F%BA%E4%BA%8EBash%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/#Basic-Implementation" class="headerlink" title="Basic Implementation"></a>Basic Implementation</h2><p>首先定位清楚，这个对<code>cd</code>的Hook只是在指令完成后，加载或者取消配置局部环境变量。因此大概实现方式和结构都有合适的选择。</p><ul><li>程序扔<code>~/.bashrc</code>里，或者<code>/etc/profile</code>里。不过我一般在GUI用konsole比较多，所以就放<code>.bashrc</code>里了，也方便dotfile管理。</li><li>把具体实现用<code>alias</code>赋别名为<code>cd</code>达到重载（或者说Hook)<code>cd</code>的目的。</li></ul><p>基于上面这两条，这是我写一个粗略实现（没干掉bash基本使用就是能用</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cd_hook</span></span>() {</span><br/><span class="line">    <span class="comment"># The normal cd</span></span><br/><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> == 0 ]; <span class="keyword">then</span></span><br/><span class="line">        <span class="built_in">cd</span></span><br/><span class="line">    <span class="keyword">else</span></span><br/><span class="line">        <span class="built_in">cd</span> <span class="string">&#34;<span class="variable">$1</span>&#34;</span> </span><br/><span class="line"><span class="keyword">fi</span></span><br/><span class="line">    <span class="comment"># If the dir contains bashrc, launch the sub shell and load it</span></span><br/><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&#34;.bashrc&#34;</span> ] &amp;&amp; [ <span class="string">&#34;<span class="subst">$(pwd)</span>&#34;</span> != <span class="string">&#34;<span class="subst">$(getent passwd $USER | awk -F &#39;:&#39; &#39;{print $6}&#39;)</span>&#34;</span> ]; <span class="keyword">then</span></span><br/><span class="line">        <span class="built_in">pushd</span> .  &gt; /dev/null</span><br/><span class="line">        bash --init-file &lt;(<span class="built_in">cat</span> /etc/profile ~/.bashrc .bashrc)</span><br/><span class="line">    <span class="keyword">fi</span></span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">alias</span> <span class="built_in">cd</span>=<span class="string">&#39;cd_hook&#39;</span></span><br/></pre></td></tr></tbody></table></figure><p>上面有依托用来检测是否是家目录的指令来避免套娃（虽然理论上充重复加载家目录配置应该没啥）,然后是检测当前目录下（因为是先<code>cd</code>过去的嘛，所以<code>pwd</code>已经变了）是否有<code>.bashrc</code>，有的话就把它作为子参数，和家目录下的bashrc一起传给子bash，然后启动它。</p><p>这样就能实现cd后自动加载目录下的配置了。赶紧试试：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment"># My blog&#39;s utiilties and aliases</span></span><br/><span class="line"><span class="built_in">set</span> -e</span><br/><span class="line">TMPL=$(find ./_scaffolds | grep .md)</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">deploy</span></span>() {</span><br/><span class="line">    <span class="built_in">cd</span> ..</span><br/><span class="line">    (</span><br/><span class="line">        <span class="built_in">rm</span> -rf deploy &amp;&amp; <span class="built_in">cp</span> -r blog deploy</span><br/><span class="line">        <span class="built_in">cd</span> deploy &amp;&amp; git checkout deploy</span><br/><span class="line">        <span class="built_in">cp</span> -r blog deploy/source</span><br/><span class="line">        <span class="built_in">cd</span> deploy &amp;&amp; pnpm i &amp;&amp; pnpm run server</span><br/><span class="line">    )</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">image_url_proc</span></span>() {</span><br/><span class="line">    find . -<span class="built_in">type</span> f -name <span class="string">&#34;*.md&#34;</span> -<span class="built_in">exec</span> sed -i <span class="string">&#39;s/\!\[\[\(.*\)\/\(.*\)\]\]/\!\[\2\]\(\/img\/\2\)/gi&#39;</span> {}</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">new_post</span></span>() {</span><br/><span class="line">    sed -e <span class="string">&#34;s/{{title}}/<span class="variable">$1</span>/&#34;</span> -e <span class="string">&#34;s/{{date}} {{time}}/<span class="subst">$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)</span>/&#34;</span> <span class="variable">$TMPL</span></span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">line_count</span></span>() {</span><br/><span class="line">    <span class="built_in">echo</span> <span class="string">&#34;You have wrote <span class="subst">$(find _* -name *.md | xargs cat 2&gt;/dev/null | wc -l)</span> lines in total!&#34;</span></span><br/><span class="line">}</span><br/></pre></td></tr></tbody></table></figure><p>cd到目录里边试试<code>line_count</code>：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/></pre></td><td class="code"><pre><span class="line">xeonds@ark-station-breeze:~/Documents/blog$ line_count</span><br/><span class="line">You have wrote 36570 lines <span class="keyword">in</span> total!</span><br/><span class="line">xeonds@ark-station-breeze:~/Documents/blog$ </span><br/></pre></td></tr></tbody></table></figure><p>好好好，再看看目录结构：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line">.</span><br/><span class="line">├── .bashrc</span><br/><span class="line">├── about</span><br/><span class="line">├── _archive</span><br/><span class="line">├── _draft</span><br/><span class="line">├── img</span><br/><span class="line">├── _inbox</span><br/><span class="line">├── links</span><br/><span class="line">├── _posts</span><br/><span class="line">└── _scaffolds</span><br/><span class="line"></span><br/><span class="line"> 9 directories, 1 files</span><br/></pre></td></tr></tbody></table></figure><p>爽死。</p><p>慢着，里边还有一行<code>pushd</code>呢。嗯，这是后面用来实现自动退出子Shell的关键。具体实现等到下一部分再说吧，先睡了。</p><blockquote><p>xeonds - Completed at Wed 27 Sep 2023 12:48:45 AM CST</p></blockquote></body></html>