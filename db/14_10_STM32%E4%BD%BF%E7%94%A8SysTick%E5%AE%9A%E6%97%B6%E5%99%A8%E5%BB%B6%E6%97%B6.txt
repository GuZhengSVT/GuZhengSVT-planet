<html><head></head><body><h1 id="STM32使用SysTick定时器延时"><a href="https://blog.ksfu.top/posts/463a/#STM32%E4%BD%BF%E7%94%A8SysTick%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BB%B6%E6%97%B6" class="headerlink" title="STM32使用SysTick定时器延时"></a>STM32使用SysTick定时器延时</h1><p>最近在学习Stm32 HAL库相关教程<del>（之前都是xjb缝合，缺少点原理的理解</del>，在看到TM1640（一个可以方便在数码管上显示内容的模块）驱动编写的过程需要用到us 级别的延时，而HAL 库的 <code>Hal_Dealy()</code>  的函数是ms 级别的，所以需要自己手动编写一个更精准的延时函数。看教程里几行不知所云，在搜索过程中大概了解到了几种写发，但是感觉比较优雅的是使用 <strong>SysTick定时器</strong> 进行延时。但是几篇教程在原理处比较简略，所以根据个人理解学习了一下。</p><h2 id="参考目录"><a href="https://blog.ksfu.top/posts/463a/#%E5%8F%82%E8%80%83%E7%9B%AE%E5%BD%95" class="headerlink" title="参考目录"></a>参考目录</h2><blockquote><p>《ARM Cortex-M3 权威指南》第3版</p><p><a href="https://www.cnblogs.com/Fireflycjd/p/14304902.html">STM32延时函数的四种方法 - Fireflycjd - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/xuqu607/p/13737040.html">STM32的SysTick延时方法 - 代码争霸 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/Leisure_ksj/article/details/105273110">STM32学习心得九：Systick滴答定时器和延时函数解读_天亮继续睡的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/haha690/article/details/111053367">stm32的systick（滴答定时器）实现精准延时_haha690的博客-CSDN博客_stm32精准定时</a></p><p><a href="https://weibo01.blog.csdn.net/article/details/81136564">STM32延时函数的四种方法：普通延时（2种）、SysTick 定时器延时（2种）_魏波-的博客-CSDN博客_delayms延时函数用法</a></p><p><a href="https://waka-can.blog.csdn.net/article/details/106527001?spm=1001.2014.3001.5506">关于STM32单片机延时微妙（delay_us）函数-hal库_好奇龙猫的博客-CSDN博客_delay_us</a></p><p><a href="https://blog.csdn.net/Firefly_cjd/article/details/106709259?spm=1001.2014.3001.5506">STM32延时函数的四种方法_strongercjd的博客-CSDN博客_stm32延时函数</a></p><p><a href="https://shequ.stmicroelectronics.cn/forum.php?mod=viewthread&amp;tid=628767">STM32高精度延时实验 (stmicroelectronics.cn)</a></p></blockquote><h2 id="几种延时方法"><a href="https://blog.ksfu.top/posts/463a/#%E5%87%A0%E7%A7%8D%E5%BB%B6%E6%97%B6%E6%96%B9%E6%B3%95" class="headerlink" title="几种延时方法"></a>几种延时方法</h2><p>第一种比较粗暴，就是让单片机做一些无关紧要的工作来打发时间，比如写点循环；</p><p>第二种是用汇编指令，和第一种大同小异；</p><p>第三种是使用SysTick滴答定时器，但是是采取 <strong>中断</strong> 的方式；</p><p>第四种是使用SysTick滴答定时器，但是是采取 <strong>查询</strong> 的方式，也就是 <strong>本次使用的方法</strong> ；</p><p>……（前三种可以在参考目录找到具体实现</p><h2 id="SysTick-定时器"><a href="https://blog.ksfu.top/posts/463a/#SysTick-%E5%AE%9A%E6%97%B6%E5%99%A8" class="headerlink" title="SysTick 定时器"></a>SysTick 定时器</h2><h3 id="简介"><a href="https://blog.ksfu.top/posts/463a/#%E7%AE%80%E4%BB%8B" class="headerlink" title="简介"></a>简介</h3><p>详细资料可以阅读 《ARM Cortex-M3 权威指南》第3版 9.5 SysTick 定时器。</p><p>SysTick 定时器是 Cortex-M 处理器内部集成的一个小型定时器，属于NVIC 的一部分，可以产生SysTick 异常。SysTick 为简单的向下计数的24位计数器，可以使用处理器时钟或者外部时钟。</p><p>SysTick 定时器可用作简单的定时器外设，用以产生周期性中断，延时或时间测量。</p><h3 id="SyTick-定时器的寄存器"><a href="https://blog.ksfu.top/posts/463a/#SyTick-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8" class="headerlink" title="SyTick 定时器的寄存器"></a>SyTick 定时器的寄存器</h3><table><thead><tr><th>地址</th><th>CMSIS-Core 符号</th><th>寄存器</th></tr></thead><tbody><tr><td>0xE000E010</td><td><code>SysTick -&gt; CTRL</code></td><td>SysTick 控制和状态寄存器</td></tr><tr><td>0xE000E014</td><td><code>SysTick -&gt; LOAD</code></td><td>SysTick 重装值寄存器</td></tr><tr><td>0xE000E018</td><td><code>SysTick -&gt; VAL</code></td><td>SysTick 当前值寄存器</td></tr><tr><td>0xE000E01C</td><td><code>SysTick -&gt; CALIB</code></td><td>SysTick 校准值寄存器</td></tr></tbody></table><h4 id="SysTick-控制和状态寄存器（SysTick-gt-CTRL）"><a href="https://blog.ksfu.top/posts/463a/#SysTick-%E6%8E%A7%E5%88%B6%E5%92%8C%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88SysTick-gt-CTRL%EF%BC%89" class="headerlink" title="SysTick 控制和状态寄存器（SysTick -&gt; CTRL）"></a>SysTick 控制和状态寄存器（<code>SysTick -&gt; CTRL</code>）</h4><table><thead><tr><th>位段</th><th>名称</th><th>类型</th><th>复位值</th><th>描述</th></tr></thead><tbody><tr><td>16</td><td>COUNTFLAG</td><td>RO</td><td>0</td><td>当SYSTICK 定时器计数到0时，该位变成1，读取寄存器或清除计数器当前值会被清零</td></tr><tr><td>2</td><td>CLKSOURCE</td><td>R/W</td><td>0</td><td>0 = 外部参考时钟（STCLK）；<br/>1 = 使用内核时钟</td></tr><tr><td>1</td><td>TOCKINT</td><td>R/W</td><td>0</td><td>1 = SYSTICK 定时器计数减至0时产生异常 <br/>0 = 不产生异常</td></tr><tr><td>0</td><td>ENABLE</td><td>R/W</td><td>0</td><td>SYSTICK 定时器使能</td></tr></tbody></table><h4 id="SysTick-重装值寄存器（SysTick-gt-LOAD）"><a href="https://blog.ksfu.top/posts/463a/#SysTick-%E9%87%8D%E8%A3%85%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88SysTick-gt-LOAD%EF%BC%89" class="headerlink" title="SysTick 重装值寄存器（SysTick -&gt; LOAD）"></a>SysTick 重装值寄存器（<code>SysTick -&gt; LOAD</code>）</h4><table><thead><tr><th>位</th><th>名称</th><th>类型</th><th>复位值</th><th>描述</th></tr></thead><tbody><tr><td>23: 0</td><td>RELOAD</td><td>R/W</td><td>未定义</td><td>定时器为0时的重装载值</td></tr></tbody></table><h4 id="SysTick-当前值寄存器（SysTick-gt-VAL）"><a href="https://blog.ksfu.top/posts/463a/#SysTick-%E5%BD%93%E5%89%8D%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88SysTick-gt-VAL%EF%BC%89" class="headerlink" title="SysTick 当前值寄存器（SysTick -&gt; VAL）"></a>SysTick 当前值寄存器（<code>SysTick -&gt; VAL</code>）</h4><table><thead><tr><th>位</th><th>名称</th><th>类信</th><th>复位值</th><th>描述</th></tr></thead><tbody><tr><td>23: 0</td><td>CURRENT</td><td>R/Wc</td><td>0</td><td>读出值位SYSTICK 定时器的当前数值。写入任何值都会清除寄存器，SYSTICK 控制和状态寄存器中的 COUNTFLAG 也会清零</td></tr></tbody></table><h4 id="SysTick-校准值寄存器（SysTick-gt-CALIB）"><a href="https://blog.ksfu.top/posts/463a/#SysTick-%E6%A0%A1%E5%87%86%E5%80%BC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88SysTick-gt-CALIB%EF%BC%89" class="headerlink" title="SysTick 校准值寄存器（SysTick -&gt; CALIB）"></a>SysTick 校准值寄存器（<code>SysTick -&gt; CALIB</code>）</h4><table><thead><tr><th>位</th><th>名称</th><th>类型</th><th>复位值</th><th>描述</th></tr></thead><tbody><tr><td>31</td><td>NOREF</td><td>R</td><td>-</td><td>1 = 没有外部参考时钟（STCLK 不可用）<br/>0 = 有外部参考时钟可供使用</td></tr><tr><td>30</td><td>SKEW</td><td>R</td><td>-</td><td>1= 校准值并非精准的 10ms<br/>0 = 校准值准确</td></tr><tr><td>23: 0</td><td>TENMS</td><td>R/W</td><td>0</td><td>10毫秒校准值。芯片设计者应通过 Cortex-M3 的输入信号提供该数值，若读出为0，则表示校准值不可用。</td></tr></tbody></table><h3 id="使用-SysTick-定时器"><a href="https://blog.ksfu.top/posts/463a/#%E4%BD%BF%E7%94%A8-SysTick-%E5%AE%9A%E6%97%B6%E5%99%A8" class="headerlink" title="使用 SysTick 定时器"></a>使用 SysTick 定时器</h3><h4 id="主要流程"><a href="https://blog.ksfu.top/posts/463a/#%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B" class="headerlink" title="主要流程"></a>主要流程</h4><p>本次使用查询的方式。</p><ol><li>将0写入 <code>SysTick -&gt; CTRL</code> 禁止 SysTick 定时器，防止之前 SysTick 定时器在之前被使能过；</li><li>将新的重加载值写入 <code>SysTick -&gt; LOAD</code> ，重加载值应为周期数减1（因为是倒数到0）；</li><li>将任何数值写入 SysTick 当前值寄存器 <code>SysTick -&gt; VAL</code> ，该寄存器会被清零；</li><li>写入 SysTick 控制和状态寄存器 <code>SysTick -&gt; CTRL</code> 启动寄存器</li></ol><h4 id="延时原理"><a href="https://blog.ksfu.top/posts/463a/#%E5%BB%B6%E6%97%B6%E5%8E%9F%E7%90%86" class="headerlink" title="延时原理"></a>延时原理</h4><p>利用SysTick 控制和状态寄存器 <code>SysTick -&gt; CTRL</code> 中的 <strong>计数标志位</strong> 来确定定时器合适变为0.可以设置 <code>SysTick -&gt; LOAD</code> 的值，然后等待计数标志位变为0，以此实现延时。</p><p>示例代码</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//禁止 SysTick 定时器</span>SysTick <span class="token operator">-&gt;</span> CTRL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//设置计数周期为256 （255~0）</span>SysTick <span class="token operator">-&gt;</span> LOAD <span class="token operator">=</span> <span class="token number">0XFF</span><span class="token punctuation">;</span><span class="token comment">// 清零当前值寄存器</span>SysTick <span class="token operator">-&gt;</span> VAL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 5 = b&#39;101</span><span class="token comment">// 位0 = 1 为使能SYSTICK定时器</span><span class="token comment">// 位2 = 1 表示使用内核时钟</span>SysTick <span class="token operator">-&gt;</span> CTRL <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">// 0x00010000 = 1&lt;&lt;16</span><span class="token comment">// 通过查询 SysTick -&gt; CTRL 第16位标志位判断计数器是否计数到0</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>SysTick <span class="token operator">-&gt;</span> CTRL <span class="token operator">&amp;</span> <span class="token number">0x00010000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//禁止 SysTick 定时器</span>SysTick <span class="token operator">-&gt;</span> CTRL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="进行-us-级别延时"><a href="https://blog.ksfu.top/posts/463a/#%E8%BF%9B%E8%A1%8C-us-%E7%BA%A7%E5%88%AB%E5%BB%B6%E6%97%B6" class="headerlink" title="进行 us 级别延时"></a>进行 us 级别延时</h3><h4 id="关于时钟"><a href="https://blog.ksfu.top/posts/463a/#%E5%85%B3%E4%BA%8E%E6%97%B6%E9%92%9F" class="headerlink" title="关于时钟"></a>关于时钟</h4><p>本次选用外部时钟。</p><p><strong>对于STM32，外部时钟源是HCLK(AHB总线时钟）的1/8，内核时钟是HCLK时钟</strong> ；</p><p>）可以翻出来 CubeMX 的时钟树看一眼</p><p><img src="https://blog.ksfu.top/img/posts/mg995/4.webp"/></p><p>以f103 为例，这里HCLK 为72MHz，那么SYSTICK 的时钟为9MHz，即 <strong>SYSTICK定时器以9MHz的频率递减</strong> 。</p><h4 id="计算"><a href="https://blog.ksfu.top/posts/463a/#%E8%AE%A1%E7%AE%97" class="headerlink" title="计算"></a>计算</h4><p>如果要获取 <strong>N</strong>us的延迟，那么我们需要计算出 <code>SysTick -&gt; LOAD</code> ，即重加载值</p><p>容易得到：</p><p>$1s = 10^6us$</p><p>$$Nus=T\times LOAD=\frac{LOAD}{SYSTICK}\times 10^6$$</p><p>$$LOAD=Nus\times SysTick \times 10^{-6}$$</p><p>已知有：</p><p>$HCLK=72MHz$</p><p>$SYSTICK=9MHz$</p><p>代入具体数值可以得到：</p><p>$LOAD=Nus\times9\times 10^6\times 10^{-6}$</p><p>最后得到</p><p>$$LOAD=Nus\times9$$</p><h4 id="72M主频代码"><a href="https://blog.ksfu.top/posts/463a/#72M%E4%B8%BB%E9%A2%91%E4%BB%A3%E7%A0%81" class="headerlink" title="72M主频代码"></a>72M主频代码</h4><p><del>）博客里面xjb找了一段</del></p><h5 id="us级延时"><a href="https://blog.ksfu.top/posts/463a/#us%E7%BA%A7%E5%BB%B6%E6%97%B6" class="headerlink" title="us级延时"></a>us级延时</h5><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*采用SysTick定时器位16标志位读取方式做延时(程序起始处)*/</span><span class="token keyword">void</span> <span class="token function">delay_us</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> nus<span class="token punctuation">)</span> <span class="token comment">//us级延时</span><span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> temp<span class="token punctuation">;</span>    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span>    SysTick<span class="token operator">-&gt;</span>LOAD<span class="token operator">=</span>nus<span class="token operator">*</span><span class="token number">9</span><span class="token punctuation">;</span>    SysTick<span class="token operator">-&gt;</span>VAL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span><span class="token comment">//清空计数器</span>    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x01</span><span class="token punctuation">;</span><span class="token comment">//使能，减到零时无动作，采用外部时钟源</span>    <span class="token comment">// 当计数器的值减小到 0 的时候， CRTL 寄存器的位 16 会置 1</span>    <span class="token comment">// 当置 1 时，读取该位会清 0</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        temp<span class="token operator">=</span>SysTick<span class="token operator">-&gt;</span>CTRL<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等待时间到达</span>    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span><span class="token comment">//关闭计数器</span>    SysTick<span class="token operator">-&gt;</span>Val<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span><span class="token comment">//清空计数器</span><span class="token punctuation">}</span><span class="token comment">/*采用SysTick定时器位16标志位读取方式做延时(程序结束处)*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h5 id="ms级延时"><a href="https://blog.ksfu.top/posts/463a/#ms%E7%BA%A7%E5%BB%B6%E6%97%B6" class="headerlink" title="ms级延时"></a>ms级延时</h5><p>循环1000次即可</p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> nms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">delay_us</span><span class="token punctuation">(</span>nms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><h3 id="更通用一点的代码"><a href="https://blog.ksfu.top/posts/463a/#%E6%9B%B4%E9%80%9A%E7%94%A8%E4%B8%80%E7%82%B9%E7%9A%84%E4%BB%A3%E7%A0%81" class="headerlink" title="更通用一点的代码"></a>更通用一点的代码</h3><p>上面那个 <code>SysTick-&gt;LOAD=nus*9;</code> 的9是手动算出来的，一般情况下主频是很容易知道的，那直接用主频自动算出这个数字就更方便了</p><p>再次回到上面的式子</p><p>记系统时钟 $SYSCLK \  Mhz$</p><p>$SYSTICK=SYSCLK\div9 \ Mhz$</p><p>$$Nus=T\times LOAD=\frac{LOAD}{SYSTICK\times10^6}\times 10^6=\frac{LOAD}{SYSTICK}$$</p><p>$$LOAD=Nus\times SYSTICK$$</p><p>这样可以在代码中定义一个延时倍乘数 <code>fac_us</code></p><p>$fac_\ us=SYSCLK\div8$</p><h3 id="代码"><a href="https://blog.ksfu.top/posts/463a/#%E4%BB%A3%E7%A0%81" class="headerlink" title="代码"></a>代码</h3><p>代码分为两步</p><ol><li>配置 <code>SYSTICK</code> 为<code>SYSCLK</code> 的$\frac{1}{8}$ ，并计算出延时倍乘数 <code>fac_us</code></li><li>采用SysTick定时器位16标志位读取方式做延时</li></ol><p><strong>还要记得在头文件包含 <code>stm32f1xx.h</code></strong> （以f103为例）</p><p><strong><code>dealy.c</code></strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token class-name">uint8_t</span>  fac_us<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//us延时倍乘数</span><span class="token comment">// 初始化延迟函数</span><span class="token comment">// SYSTICK的时钟固定为AHB时钟的1/8</span><span class="token comment">// SYSCLK:系统时钟频率</span><span class="token keyword">void</span> <span class="token function">delay_init</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> SYSCLK<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">HAL_SYSTICK_CLKSourceConfig</span><span class="token punctuation">(</span>SYSTICK_CLKSOURCE_HCLK_DIV8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//配置SYSTICK </span>fac_us<span class="token operator">=</span>SYSCLK<span class="token operator">/</span><span class="token number">8</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//采用SysTick定时器位16标志位读取方式做延时(程序起始处)</span><span class="token comment">//us级延时</span><span class="token keyword">void</span> <span class="token function">delay_us</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> nus<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> temp<span class="token punctuation">;</span>    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span>    SysTick<span class="token operator">-&gt;</span>LOAD<span class="token operator">=</span>nus<span class="token operator">*</span>fac_us<span class="token punctuation">;</span>    SysTick<span class="token operator">-&gt;</span>VAL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span><span class="token comment">//清空计数器</span>    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x01</span><span class="token punctuation">;</span><span class="token comment">//使能，减到零时无动作，采用外部时钟源</span>    <span class="token comment">// 当计数器的值减小到 0 的时候， CRTL 寄存器的位 16 会置 1</span>    <span class="token comment">// 当置 1 时，读取该位会清 0</span>    <span class="token keyword">do</span><span class="token punctuation">{</span>        temp<span class="token operator">=</span>SysTick<span class="token operator">-&gt;</span>CTRL<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token number">0x01</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token operator">!</span><span class="token punctuation">(</span>temp<span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 等待时间到达</span>    SysTick<span class="token operator">-&gt;</span>CTRL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span><span class="token comment">//关闭计数器</span>    SysTick<span class="token operator">-&gt;</span>VAL<span class="token operator">=</span><span class="token number">0x00</span><span class="token punctuation">;</span><span class="token comment">//清空计数器</span><span class="token punctuation">}</span><span class="token comment">//采用SysTick定时器位16标志位读取方式做延时(程序结束处)</span><span class="token comment">//ms级延时</span><span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> nms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">delay_us</span><span class="token punctuation">(</span>nms<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure><p><strong><code>delay.h</code></strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&#34;stm32f1xx.h&#34;</span></span><span class="token keyword">void</span> <span class="token function">delay_init</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span> SYSCLK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">delay_us</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> nus<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">delay_ms</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span> nms<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div></figure><blockquote><p> <strong>函数 <code>HAL_SYSTICK_CLKSourceConfig()</code></strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/**  * @brief  Configures the SysTick clock source.  * @param  CLKSource specifies the SysTick clock source.  *          This parameter can be one of the following values:  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.  * @retval None  */</span><span class="token keyword">void</span> <span class="token function">HAL_SYSTICK_CLKSourceConfig</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> CLKSource<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">/* Check the parameters */</span>  <span class="token function">assert_param</span><span class="token punctuation">(</span><span class="token function">IS_SYSTICK_CLK_SOURCE</span><span class="token punctuation">(</span>CLKSource<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>CLKSource <span class="token operator">==</span> SYSTICK_CLKSOURCE_HCLK<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    SysTick<span class="token operator">-&gt;</span>CTRL <span class="token operator">|=</span> SYSTICK_CLKSOURCE_HCLK<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span>    SysTick<span class="token operator">-&gt;</span>CTRL <span class="token operator">&amp;=</span> <span class="token operator">~</span>SYSTICK_CLKSOURCE_HCLK<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure></blockquote><h2 id="总结"><a href="https://blog.ksfu.top/posts/463a/#%E6%80%BB%E7%BB%93" class="headerlink" title="总结"></a>总结</h2><p>最后看下来就是 <strong>设置重装载值，使能，检查标志位</strong> 这三个步骤。</p><p>还有就是书上讲的是比较清楚详细的。<span class="diana_jiayou"></span></p></body></html>