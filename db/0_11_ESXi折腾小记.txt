<html><head></head><body><h2 id="序"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E5%BA%8F" class="headerlink" title="序"></a>序</h2><p>其实理论上这玩意早都折腾好了。</p><p>只不过不满意于当时的家用板子（B450MK+1500X）对于ESXi兼容性太差，后来又换回了Windows+VMWare的组合。这组合咋用咋不爽，所以最后攒了点钱，整了一套服务器平台（联想的X99板子+E5 2680V4 x2+16G DDR4 ECC，一共大概600大洋），不过因为一些原因拖到最近才空出时间调试好。</p><h2 id="硬件"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E7%A1%AC%E4%BB%B6" class="headerlink" title="硬件"></a>硬件</h2><p>本来机子6月已经装好了，但是一直处于开机不亮屏的状态。昨个跟卖家唠嗑了老久，调试了半天才发现这板子好像只知道集成显卡输出，就好像它不知道自己上边还插着个1080一样。</p><p>没办法，集显就集显吧，反正确实能用，还能省点电呢（=。=）</p><p>进了U盘，启动ESXi镜像，直接开装。因为是服务器板子，所以不用担心网卡支持之类的问题，反正很顺利地装完了。旁边的弱电柜看着挺好，里边还有个交换机来着，但是看到那密密麻麻的走线，折腾了一下就放弃了（而且这玩意要管理还得插串口线，笑死，根本找不到）。</p><p>于是直接把机器插到路由器上了。千兆网，爽死。</p><p>整好网络配置之后已经很晚了，遂直接回宿舍，来日再整。</p><h2 id="系统"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E7%B3%BB%E7%BB%9F" class="headerlink" title="系统"></a>系统</h2><p>昨天才装好ESXi，今天下午急冲冲跑到实验室装好了Ubuntu，然后想整个OpenWRT当旁路由，但是发现目前还没啥必要，于是作罢，就用Ubuntu直接开始吧（反正比Windows好</p><p>随便装了装软件啥的。先是试着用刚学的sed给apt换了个源，然后装了docker，zip啥的。有了docker之后，直接把笔记本上的mc服务器扔了上去+docker run光速部署。真香。</p><p>然后慢慢折腾回以前的服务。首先是gitea，1.20居然都支持ci/cd了，这不狠狠部署？但是我以前的数据还在硬盘上扔着，于是先整了下物理硬盘的vhd映射。下面记录一下：</p><p>打开ESXi的SecureSHell（ssh）服务之后，用它的管理账户密码登录上去，然后运行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /vmfs/devices/disks/</span><br/></pre></td></tr></tbody></table></figure><p>查看系统挂载的硬盘信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/></pre></td><td class="code"><pre><span class="line">t10.ATA_____ST2000DM0052D2CW102__________________________________WFL1DE7T</span><br/><span class="line">t10.ATA_____ST2000DM0052D2CW102__________________________________WFL1DE7T:1</span><br/><span class="line">t10.ATA_____ST2000DM0052D2CW102__________________________________WFL1DE7T:5</span><br/><span class="line">t10.ATA_____ST4000VX0002D2AG166__________________________________ZDHA1DHG</span><br/><span class="line">t10.ATA_____ST4000VX0002D2AG166__________________________________ZDHA1DHG:1</span><br/><span class="line">t10.ATA_____ST4000VX0002D2AG166__________________________________ZDHA1DHG:2</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:1</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:2</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:3</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:5</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:6</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:7</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:8</span><br/><span class="line">t10.NVMe____ORICO_V500_128GB________________________0000000000000001:9</span><br/><span class="line">vml.010000000020202020202020202020202057464c3144453754535432303030</span><br/><span class="line">vml.010000000020202020202020202020202057464c3144453754535432303030:1</span><br/><span class="line">vml.010000000020202020202020202020202057464c3144453754535432303030:5</span><br/><span class="line">vml.01000000002020202020202020202020205a44484131444847535434303030</span><br/><span class="line">vml.01000000002020202020202020202020205a44484131444847535434303030:1</span><br/><span class="line">vml.01000000002020202020202020202020205a44484131444847535434303030:2</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:1</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:2</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:3</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:5</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:6</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:7</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:8</span><br/><span class="line">vml.0100000000303030305f303030305f303030305f30303031004f5249434f20:9</span><br/></pre></td></tr></tbody></table></figure><p>然后找到硬盘对应的编号，然后用<code>vmkfstools</code>把硬盘映射到vhd文件里：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">vmkfstools -z /vmfs/devices/disks/[target disk] /vmfs/voluems/datastore1/[target vhd <span class="built_in">link</span> name].vmdk</span><br/></pre></td></tr></tbody></table></figure><p>完成之后，在虚拟机编辑里添加硬盘，选择现有硬盘，在里边找到刚才新建的两个硬盘映射vhd文件。</p><p>挂载到虚拟机上之后，开机，我们还得把硬盘挂载到系统上。</p><p>硬盘加到虚拟机上之后，一般会以<code>/dev/sd[a-z]</code>的形式出现，这种时候只需要用<code>fdisk</code>康康磁盘上有什么好康的分区就行啦。不过我这盘好像被Windows的快速启动污染了，得先在Windows里挂载一下，正常关机才能挂载到Linux底下。</p><p>所以，现在本来要装Windows来着，但是突然发现Vmware里边有个叫上载虚拟机的东东：</p><p><img src="https://xeonds.github.io/img/Pasted%20image%2020230721220805.png"/></p><p>然后就懒得装了，直接把以前的老虚拟机传上去了。开机前设置下硬盘挂载，然后直接开机再关机，搞定。</p><p>配置完成之后，发现果然还是另外整个系统当frp的客户端比较稳定。挑了半天发现还是OpenWRT最方便，于是在<a href="https://supes.top/?target=x86/64&amp;id=generic">OpenWrt软路由固件下载与在线定制编译</a>这里下了个x86架构的编译版本装上了。启动之后应该就能正常访问了，就是得先配置下网络的配置文件（我这边为了网络环境方便访问，配置的是bridge桥接模式，所以得手动重新设置网关、地址之类的）。配置相关的内容，恩山有不少内容可以参考。</p><p>总之一番折腾下来配好旁路由和内网穿透<del>以及基本不咋用的局域网代理</del>之后，折腾就基本结束了</p><p>直到我发现安装系统选项底下有个MacOS。装都装了，不试试怎么行呢（不过据了解，黑果在ESXi虚拟化环境下体验不行，更建议物理机</p><blockquote><p>TODO：等啥时候加个ssd扩容系统盘再说吧。。空间居然不够用了</p></blockquote><h3 id="自动启动"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8" class="headerlink" title="自动启动"></a>自动启动</h3><p>装完机器之后想配置宿主机启动后，子主机跟着自动启动。但是在机器的虚拟机设置里边开开了自动启动之后，却没有按照预期开机自动启动VM。排查一番之后发现原来还有个设置没开。</p><p>从左侧导航栏到<code>主机-&gt;管理-&gt;系统-&gt;自动启动</code>，点编辑设置，把自动启动打开就行。</p><p>这边的两个延时，指的是ESXi启动/关闭所有虚拟机的间隔时间，全局设置会被主机的设置覆盖。而等待检测信号（Wait for heartbeat）指的是，在VM中安装VMWare工具后，系统启动完成后会告知宿主机。此时，如果这个设置为真，则ESXi会跳过启动等待时间，去启动下一个系统。</p><h3 id="磁盘缩容"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E7%A3%81%E7%9B%98%E7%BC%A9%E5%AE%B9" class="headerlink" title="磁盘缩容"></a>磁盘缩容</h3><p>为啥缩小容量呢？因为ESXi系统盘大小不够用了，新系统塞不进去（挠头</p><p>装了个Windows Server 2012 R2 Datacenter尝尝鲜，在本子上配置好之后觉得还挺香，遂打算扔服务器上，然后因为上面的原因卡住。</p><p>解决方法分两步。先声明一下，我是单磁盘系统，如果是多磁盘还得自己探索探索（</p><p>首先用Disk Genius（其实系统自带的磁盘管理也行）打开<code>vmdk</code>磁盘，然后把系统分区缩小到目标容量，剩下的空间留空就行。完成后保存退出Disk Genuis。</p><p>然后用随便一个文本编辑器打开<code>vmdk</code>文件，最上面几行有一行表示磁盘簇大小的，大小是磁盘容量（KB）的二倍，修改它到合适的大小就行。</p><p><img src="https://xeonds.github.io/img/Pasted%20image%2020231030214637.png" alt="随便找了个图图"/></p><p>就是RW一行，改成合适的大小就行。</p><p>编辑完成之后直接用VMWare Workstation传到ESXi主机上就OK了。这一点不得不夸下，配套的东西确实挺好用。</p><h2 id="服务"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E6%9C%8D%E5%8A%A1" class="headerlink" title="服务"></a>服务</h2><p>折腾好服务器了，就得想想作何用途了。整理出来的大概有这些：</p><table><thead><tr><th>Service</th><th>Description</th></tr></thead><tbody><tr><td>gitea</td><td>代码托管和CI/CD</td></tr><tr><td>cloudreve</td><td>私有云，数据管理以及WebDAV数据备份同步</td></tr><tr><td>minecraft</td><td>这肯定必装啊，大型开放世界游戏（无误</td></tr><tr><td>jupyter</td><td>都装N卡了，不玩玩深度学习？</td></tr><tr><td>database</td><td>当Web服务后端，香就一个字</td></tr><tr><td>compile</td><td>这可是56线程啊，我以后写个helloworld都要<code>make -j56</code>（大声</td></tr><tr><td>calculate</td><td>渲染和其他计算任务倒是可以试试丢上来跑</td></tr><tr><td>vm server</td><td>给别人也整几个虚拟机用用</td></tr><tr><td>web services</td><td>挂点WEB服务上去，岂不美哉</td></tr><tr><td>mirror site</td><td>整个镜像站，功德无量啊功德无量</td></tr><tr><td>others</td><td>后面再想</td></tr></tbody></table><blockquote><p>先配服务器再想应用场景，有一种先射击再瞄准的美</p></blockquote><p>目前搭建的基本就是<code>gitea, mc, cloudreve, jupyter, mysql</code>这几个，后台还跑着一些运维脚本，目前这些已吃完我的内存了QAQ。总之简述下搭建流程吧。毕竟是个blog不是manual，就不贴太详细的步骤了。如果给出了指令，请确保在理解的情况下，按照真实系统环境执行。</p><h3 id="gitea"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#gitea" class="headerlink" title="gitea"></a>gitea</h3><p>这个搭建起来很简单，直接wget最新的build到你要安装的目录，然后把官方的service配置cat到<code>/etc/systemd/system/gitea.service</code>，再<code>sudo systemctl enable --now gitea.service</code>，之后再在给出的Web链接里配置好服务，最后修改好<code>config.ini</code>再重启服务就好了。</p><p>很好用的客户端</p><h3 id="cloudreve"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#cloudreve" class="headerlink" title="cloudreve"></a>cloudreve</h3><p>跟上面基本一样，先wget下来，再运行一下产生配置文件并修改好设置，并配置好systemd的服务管理，最后启动就行。不过，安装完成后，还得配置下<strong>存储策略</strong>来确定文件存储的物理位置，并在用户组中修改每种用户的空间限额大小和权限等。</p><p>这东西我最喜欢的点是支持WebDAV，所以配合上AutoSync之类的客户端，就能实现数据增量备份和同步。</p><h3 id="Minecraft"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#Minecraft" class="headerlink" title="Minecraft"></a>Minecraft</h3><p>喜闻乐见的MC时间。这边我是用Docker开服的，环境最干净，并且最方便于管理。具体参考以前写过的Docker-MC开服的博文。</p><p>这次为了运维简单，使用了某docker镜像来开服。官方服的唯一优点估计只剩下官方俩字了，实际表现可以说是一般环境一般，弱网环境逆天。据说原因是因为官方服务器只要丢包发生，无论几个都给你踢了。</p><p>所以建议用<code>Paper</code>之类的第三方服务端，性能好的多。</p><h3 id="JupyterLab"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#JupyterLab" class="headerlink" title="JupyterLab"></a>JupyterLab</h3><p>直接<code>python3 -m pip install jupyterlab</code>或者用<code>apt, pacman</code>之类的包管理器安装就行。装完了照着上面的在systemd把它添加为服务就行。装好之后，直接浏览器访问端口使用就行了。</p><p>唯一要注意的就是安全性了，注意设个复杂点的密码，小心暴力破解。</p><h3 id="database"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#database" class="headerlink" title="database"></a>database</h3><p>刚好这边有个项目得用数据库，所以就用docker开了个mysql的daemon当数据库。不得不说是真的方便</p><h3 id="Compiling-Service"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#Compiling-Service" class="headerlink" title="Compiling Service"></a>Compiling Service</h3><p>这部分我是用gitea-action搞定的。其他时候，我一般直接ssh到服务器上手动编译。不过注意，<strong>服务器的稳定性至关重要</strong>，别随便跑啥若治脚本把服务器玩炸了。数据可靠性很关键。特别是当你的服务器还挂了一堆存着重要数据的硬盘，要是真手欠<code>rm -rf</code>了你哭都没地方去。所以建议这种任务通通扔docker，反正没啥性能损失。</p><h3 id="Calculation"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#Calculation" class="headerlink" title="Calculation"></a>Calculation</h3><p>用JupyterLab能搞定一部分<del>反正他们数据科学的基本全是python</del>，另一部分相对需求较小的，就直接跑专门的计算进程算了。</p><p>由于计算任务的强性能需求和性能抢占特性，务必设置守护进程等手段，防止一个计算任务炸了整个服务器。</p><blockquote><p>实在不行在ESXi再开个机器专门跑计算。（</p></blockquote><h3 id="VM-Servers"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#VM-Servers" class="headerlink" title="VM Servers"></a>VM Servers</h3><p>打算先搓个轮子，然后基于这个轮子整个自动new container并绑定账号和tty的web service。安全性问题后面再说，这些机器可以用来租借或者提供给其他人学习使用。</p><h3 id="Web-Services"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#Web-Services" class="headerlink" title="Web Services"></a>Web Services</h3><p>比如可以把<code>XDU-ISC</code>的主页/blog挂上去，或者挂点其他Web服务，比如自动打卡之类的。</p><h3 id="Mirror-Site"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#Mirror-Site" class="headerlink" title="Mirror Site"></a>Mirror Site</h3><p>给各种大型镜像源整个分流，分担下压力造福开源——不过我这点硬盘容量就算了罢。</p><blockquote><p>2023.11.03 昨天<code>Clash For Windows</code>删库，今天<code>clash core</code>和其他<code>Clash</code>系的全部删库<br/>哎 常用软件还是得整份源码小心删库<br/>实在不行也能自己维护。</p></blockquote><h3 id="Samba"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#Samba" class="headerlink" title="Samba"></a>Samba</h3><p>开个Samba给Windows共享用还是挺爽的。Win的Native WebDAV好像有点问题，不然就省事了。</p><p>详细配置教程可以参考<a href="https://ubuntu.com/tutorials/install-and-configure-samba#1-overview">Ubuntu tutorials - Install and configure samba</a>。我搬个简略版的下来：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install samba</span><br/><span class="line"><span class="comment"># 创建你要共享的目录</span></span><br/><span class="line"><span class="built_in">mkdir</span> ~/sambashare</span><br/><span class="line"><span class="comment"># 编辑samba配置文件</span></span><br/><span class="line"><span class="comment"># 为了以命令形式展示这边用了古法编辑</span></span><br/><span class="line"><span class="comment"># 建议用Vim/sed/nano之类的搞定</span></span><br/><span class="line">sudo <span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt;&gt; /etc/samba/smb.conf</span></span><br/><span class="line"><span class="string">[sambashare]</span></span><br/><span class="line"><span class="string">    comment = Samba on Ubuntu</span></span><br/><span class="line"><span class="string">    path = /home/username/sambashare</span></span><br/><span class="line"><span class="string">    read only = no</span></span><br/><span class="line"><span class="string">    browsable = yes</span></span><br/><span class="line"><span class="string">EOF</span></span><br/><span class="line">sudo systemctl <span class="built_in">enable</span> --now smbd &amp;&amp; sudo service start samba</span><br/><span class="line"><span class="comment"># 更改samba共享账户和密码</span></span><br/><span class="line"><span class="comment"># 这个用户账户得是系统中现存的账户</span></span><br/><span class="line">sudo smbpasswd -a [username]</span><br/><span class="line"><span class="comment"># 然后根据指引设定共享密码，完成</span></span><br/></pre></td></tr></tbody></table></figure><p>完成后，从其他机器上以<code>\\ip-address\sambashare</code>就能访问共享的目录。</p><h3 id="其他服务"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1" class="headerlink" title="其他服务"></a>其他服务</h3><p>其他服务的话，比如我写的<code>NanoOJ</code>就可以挂上去给搞算法竞赛的<del>小东西</del>们训练用，也可以把我写那个<code>XDU-Planet</code>挂上去，聚合大家的博客<del>黑历史</del>博文，还能整点其他的花活。</p><blockquote><p>最近把<code>XDU-Planet</code>贡献给<code>XDOSC</code>社区了，目前挂了很多人的<del>黑</del>历史，可以来<a href="https://xdlinux.github.io/planet/">Planet</a>看看。</p></blockquote><p>总之，充分利用嘛。</p><h2 id="运维"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E8%BF%90%E7%BB%B4" class="headerlink" title="运维"></a>运维</h2><p>服务器的躯体是硬件，灵魂是数据。物理上的安全备份这里先不论，这里主要说说数据上的安全和管理。</p><h3 id="数据安全"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8" class="headerlink" title="数据安全"></a>数据安全</h3><p>磁盘上的数据无非就程序，配置和存储的重要数据文件这三类，下面分开说。</p><h4 id="程序"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E7%A8%8B%E5%BA%8F" class="headerlink" title="程序"></a>程序</h4><p>大部分程序只是一份可以重新安装下载的数据文件，所以我们只需要备份它的程序列表即可。在迁移系统或者出现重大损失时，我们只需要拿到程序列表，然后用你最喜欢的包管理器批量安装这些程序即可。假设你使用<code>apt</code>作为包管理器：前者可以通过<code>dpkg --get-selections &gt; backup.txt</code>做到，后者可以通过<code>sudo apt-get update &amp;&amp; sudo apt-get install $(awk &#39;{print $1}&#39; backup.txt)</code>做到。</p><p>当然，上面的实现只是最基础的。我们可以使用<code>awk, git</code>等工具把这件事做的更好。以上面两行脚本为基础原理，我们可以编写一个借助<code>git</code>进行备份记录的版本控制和备份，借助<code>awk</code>让备份的程序列表更加可读和强大，借助<code>alias</code>和<code>bashrc</code>为安装增加一个更新应用列表的hook，利用<code>crontab</code>实现备份的无人值守和自动化，并且可以增加应用的版本信息以及特定版本安装等等。</p><p>甚至，对于不在apt的软件，也可以手动记录，甚至是直接保存ELF到备份仓库中。</p><p>借助这个工具，灾难恢复也会变得相对简单。</p><blockquote><p>TODO：后边实现这个脚本，先插个flag在这</p></blockquote><h4 id="配置"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E9%85%8D%E7%BD%AE" class="headerlink" title="配置"></a>配置</h4><p>Linux下的大多数配置文件因为都以一个点（dot）开头，所以也叫dotfile。我总结的最佳实践应该是利用Git和Hard-Link去进行管理。比较麻烦的是dotfiles的恢复，这个工作也可以写一个脚本完成，自动根据记录的配置文件路径（存储于csv文件中）去自动创建硬链接来管理。这个方法基本没啥问题，就是容易遇到各种莫名其妙的失效问题，以及在termux里边由于没有root权限不能创建符号链接就很难受。</p><p>这里有篇文章，讲解的更加详细：<a href="https://medium.com/@simontoth/best-way-to-manage-your-dotfiles-2c45bb280049">Best way to manage your dotfiles</a>，也比较接近我的观念。还有这篇也值得参考：<a href="https://medium.com/@simontoth/best-way-to-manage-your-dotfiles-2c45bb280049">Best way to manage your dotfiles</a></p><p>参考上面的思路，对dotfiles的管理可以帮你<del>在你电脑炸了的时候</del>快速重建你的环境配置，以及回溯以前的配置文件，又或者是同步你的环境到其他机器上。舒适度拉满.jpg</p><h4 id="数据"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E6%95%B0%E6%8D%AE" class="headerlink" title="数据"></a>数据</h4><p>这部分我做的最早。不过方案嘛，主打一个能用就行。</p><p>具体而言，首先在各个需要备份的目录下写一个<code>backup.sh</code>来生成要备份的文件，比如这个：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line">FNAME=<span class="string">&#34;[backup]mc-server-<span class="variable">$NAME</span>-<span class="subst">$(date +%Y%m%d%H%M%S)</span>.zip&#34;</span></span><br/><span class="line">NAME=<span class="string">&#34;my-server&#34;</span></span><br/><span class="line">zip -qr <span class="variable">$FNAME</span> <span class="variable">$NAME</span>/</span><br/><span class="line"><span class="built_in">echo</span> <span class="variable">$FNAME</span></span><br/></pre></td></tr></tbody></table></figure><p>注意，必须输出生成的文件名称，后面有用。</p><p>然后随便找个地方写个脚本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br/><span class="line"><span class="comment"># 使用Bash实现的自动备份工具</span></span><br/><span class="line"><span class="comment"># 注意，绝对不能备份当前目录，不然会产生无限递归</span></span><br/><span class="line"></span><br/><span class="line">BACKUP_DIR=$(<span class="built_in">dirname</span> <span class="string">&#34;<span class="variable">$0</span>&#34;</span>)</span><br/><span class="line"></span><br/><span class="line"><span class="built_in">set</span> -e <span class="comment"># 在出现错误时自动退出</span></span><br/><span class="line"><span class="built_in">set</span> -u <span class="comment"># 在使用未定义的变量时自动退出</span></span><br/><span class="line"><span class="built_in">set</span> -o pipefail <span class="comment"># 在管道中的任何一个命令出错时自动退出</span></span><br/><span class="line"></span><br/><span class="line"><span class="keyword">while</span> IFS= <span class="built_in">read</span> -r line; <span class="keyword">do</span>                     <span class="comment"># 循环处理每一个备份任务</span></span><br/><span class="line">  <span class="keyword">if</span> [[ -z <span class="string">&#34;<span class="variable">$line</span>&#34;</span> || <span class="string">&#34;<span class="variable">$line</span>&#34;</span> =~ ^<span class="comment"># ]]; then    # 不执行注释和空行</span></span><br/><span class="line">    <span class="built_in">continue</span></span><br/><span class="line">  <span class="keyword">fi</span></span><br/><span class="line">  <span class="comment"># 使用awk得到任务参数</span></span><br/><span class="line">  SOURCE=$(awk -F, <span class="string">&#39;{print $1}&#39;</span> &lt;&lt;&lt; <span class="string">&#34;<span class="variable">$line</span>&#34;</span>)</span><br/><span class="line">  TARGET=$(awk -F, <span class="string">&#39;{print $2}&#39;</span> &lt;&lt;&lt; <span class="string">&#34;<span class="variable">$line</span>&#34;</span>)</span><br/><span class="line">  MAX=$(awk -F, <span class="string">&#39;{print $3}&#39;</span> &lt;&lt;&lt; <span class="string">&#34;<span class="variable">$line</span>&#34;</span>)       <span class="comment"># 最大保留备份数量</span></span><br/><span class="line"></span><br/><span class="line">  <span class="built_in">echo</span> <span class="string">&#34;[<span class="subst">$(date)</span>] Backing up <span class="variable">$SOURCE</span> to <span class="variable">$TARGET</span> with max <span class="variable">$MAX</span> items&#34;</span></span><br/><span class="line">  <span class="built_in">cd</span> <span class="string">&#34;<span class="variable">$SOURCE</span>&#34;</span> &amp;&amp; ./backup.sh | xargs <span class="built_in">mv</span> -t <span class="string">&#34;<span class="variable">$TARGET</span>&#34;</span></span><br/><span class="line">  <span class="built_in">echo</span> <span class="string">&#34;[<span class="subst">$(date)</span>] Backup source <span class="variable">$SOURCE</span> completed&#34;</span></span><br/><span class="line">  <span class="built_in">cd</span> <span class="string">&#34;<span class="variable">$TARGET</span>&#34;</span> &amp;&amp; <span class="built_in">ls</span> -t | <span class="built_in">tail</span> -n +$((MAX+<span class="number">1</span>)) | xargs <span class="built_in">rm</span> -f</span><br/><span class="line"><span class="keyword">done</span> &lt; <span class="string">&#34;<span class="variable">$BACKUP_DIR</span>/config.csv&#34;</span>                 <span class="comment"># 备份任务配置数据位于脚本所在目录</span></span><br/></pre></td></tr></tbody></table></figure><p>注释比较详细就不细说了。接下来在同级目录下<code>touch config.csv</code>来保存备份条目信息，举个例子：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"># src,target,max-items</span><br/><span class="line">/home/xeonds/mc-server,/mnt/c/backup/mc-server-backup/atelier-of-zimin,4</span><br/></pre></td></tr></tbody></table></figure><p>然后把上面的脚本加入<code>crontab</code>中定时运行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">0 4 * * *  output=$(/home/xeonds/backup/backup.sh); pushplus <span class="string">&#34;自动备份任务完成&#34;</span> <span class="string">&#34;<span class="variable">$output</span>&#34;</span></span><br/></pre></td></tr></tbody></table></figure><p>上面的就是我正在用的的自动备份方案，<code>pushplus</code>参考我写的Bash学习笔记。</p><p>总体就突出一个刚好能用。</p><p>另外我记得好像推荐<code>rsync</code>做增量备份的来着，不过我的这些数据可能不太适合增量备份所以没用。如果是照片一类的文件，倒是很适合rsync来处理。回头可以抽空升级下这个脚本。</p><h3 id="硬件安全"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E7%A1%AC%E4%BB%B6%E5%AE%89%E5%85%A8" class="headerlink" title="硬件安全"></a>硬件安全</h3><p>首当其冲就是硬盘安全。这方面可以用<code>smartctl</code>来定期监测SMART信息确认磁盘状态。我试了下，好像ESXi里边我映射的硬盘也支持检测SMART信息。这里也可以写个脚本定期监测并发送监测报告<del>此处可本</del>。</p><blockquote><p>天天脚本脚本，那么<del>你们程序员移一定都是足控吧.jpg</del></p></blockquote><p>其他的嘛……暂时莫得啥需求。</p><h3 id="数据管理"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86" class="headerlink" title="数据管理"></a>数据管理</h3><p>很喜欢Bash的一句话：<code>man bash</code>。</p><p>如何整理磁盘上的文件？问问<code>mv, cp, ls, rm, cat, grep, sed, awk, xargs</code>；然后，用bash把它们拼起来就行。只要你想，你可以编写出任何脚本来整理你的所有文件。</p><blockquote><p>TODO：具体的脚本太多了，这里地方小，写不下（溜</p></blockquote><h3 id="自动运维"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E8%87%AA%E5%8A%A8%E8%BF%90%E7%BB%B4" class="headerlink" title="自动运维"></a>自动运维</h3><p>都Linux了不得写个脚本帮自己干活？而且还有其他好用的工具呢，首当其冲的还得是<code>systemctl</code>，<code>crontab</code>，一个自动管理后台服务，一个自动运行任务，堪称运维两大法器。<code>systemctl</code>多用来自动启动和重启后台服务，<code>crontab</code>作为一个定时器，基本跟时间相关的任务都能干，比如<del>自动报时</del>，定时清理，定时重启，定时更新，定时打卡，定时发送状态简报，定时发送邮件，<del>定时煮饭</del>等等你能想到想不到的。</p><p>另外，还有<code>bash</code>和<code>alias</code>，前者不光能跟你<del>打</del>交互，还能连接很多强大的工具；后者不光是个别名，还能帮你hook各种命令，给它们加点小功能。这部分建议多读读命令行的艺术，以及<code>man bash</code>的内容，更重要的是得多用。</p><p>我整完这些之后，感觉还是不太过瘾。毕竟这些功能全能点的面板估计也能做到，而且我也不可能到处因为一点小事就ssh到服务器上吧）</p><p>在接触了低代码表单的思想之后，我就又想造轮子了：搓个工具，借助低代码系统，写出自己的运维管理面板，最好是实现一个页面一个配置文件，改配置文件就更新对应页面和后面调用的命令的程度。</p><p>借助这个工具倒是可以实现很轻量，而且完全自由的服务器控制面板，而且无需依赖，可定制度拉满那种。</p><blockquote><p>TODO：这里也挖个坑立个flag</p></blockquote><p>上面那段倒是偏离自动运维这个话题了。说回正题：除了上面提到的<code>systemd</code>和<code>crontab</code>之外，还可以让系统监听一些事件，并做出即时响应。</p><blockquote><p>这里先放个UNIX哲学（）</p></blockquote><p>比如让系统读取某进程的日志输出，如果输出带有ERROR等字样，就发送警告给运维，或者执行其他的动作。，我们可以将触发的部分和执行的部分分离，让系统对不同的问题做出响应。比如收到了内存不足的警报，那就自动执行<code>sudo echo 3 &gt; /proc/sys/vm/drop_caches</code>来释放内存，还是过高的话就报警<del>并随机kill一个幸运进程</del>；比如有个<del>若治</del>同事又把你数据库炸了给你发邮件求助，那系统就直接roll back数据库；再比如监测到系统设备panic了，直接发送警报并紧急关机系统防止进一步损失；还可以接收UPS的断电信号，发送警报并迅速关机来避免更大的损失；有什么登录失败的/疑似端口爆破的，直接自动ban了它的IP；再比如系统流量激增，直接报警；再比如ban了<code>sudo rm -rf /</code>这种敏感操作；甚至自动审核各种请求等等。只有想不到，没有做不到<del>除了生孩子</del>。</p><h2 id="尾声"><a href="https://xeonds.github.io/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ESXi%E6%8A%98%E8%85%BE%E5%B0%8F%E8%AE%B0/#%E5%B0%BE%E5%A3%B0" class="headerlink" title="尾声"></a>尾声</h2><p>到这里，我的服务器就基本折腾好了。我现在拥有一个数据安全性相对较高的NAS，一个日常开发可用的自动化编译/部署服务，一个代码托管和备份系统，一个7x24可用的mc服务器，一个可用于数据科学/AI学习的在线算力，一个可以随时启动的，一个可以租借给他人的docker vm实例集群，甚至是一个会自己维护自己，会帮我处理各种浪费时间的重复任务，并且易于灾难恢复和迁移的系统，以及一个Linux新手应该具备的系统管理心得经验。</p><p>可以说，这些投入，物超所值。</p></body></html>