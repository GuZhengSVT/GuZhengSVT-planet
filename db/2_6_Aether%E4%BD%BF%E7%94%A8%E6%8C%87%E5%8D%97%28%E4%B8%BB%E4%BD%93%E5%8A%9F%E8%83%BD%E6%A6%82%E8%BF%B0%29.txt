<html><head></head><body><p>相关文章：《<a href="https://xiue233.github.io/2023/09/05/aether-in-android/" title="Aether在Android中的适配探索">Aether在Android中的适配探索</a>》</p><p><strong>本文所用Aether版本为1.1.0。</strong></p><h2 id="Get-Started"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><p>Aether作为一个具有依赖注入(Dependency Injection)设计思想的库，它的主体System只能接受所依赖工具的interface实现，所以我们在调用前需要完成所需工具类的初始化(或是指定类，由Aether进行主动实例化)。</p><p>Aether提供了<code>org.apache.maven.repository.internal.MavenRepositorySystemUtils</code>工具类以方便快速配置，虽然但是，我们仍需创建一个Factory来封装完整的初始化逻辑。</p><pre><code class="java">import org.apache.maven.repository.internal.MavenRepositorySystemUtils;import org.eclipse.aether.connector.wagon.WagonProvider;import org.eclipse.aether.connector.wagon.WagonRepositoryConnectorFactory;...    private static RepositorySystem newRepositorySystem()    {        DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();        locator.addService( RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class );        locator.addService( TransporterFactory.class, FileTransporterFactory.class );        locator.addService( TransporterFactory.class, HttpTransporterFactory.class );        return locator.getService( RepositorySystem.class );    }    private static RepositorySystemSession newSession( RepositorySystem system )    {        DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();        LocalRepository localRepo = new LocalRepository(&#34;依赖库文件储存路径&#34;);        session.setLocalRepositoryManager(system.newLocalRepositoryManager(session,localRepo));        return session;    }...</code></pre><p>完成初始化逻辑封装后，假如需要下载一个远程依赖(例如,<code>org.apache.maven:maven-profile:2.2.1</code>)我们只需:</p><pre><code class="java">public static void main( String[] args )        throws Exception    {        RepositorySystem repoSystem = newRepositorySystem();        RepositorySystemSession session = newSession( repoSystem );        Dependency dependency =            new Dependency( new DefaultArtifact( &#34;org.apache.maven:maven-profile:2.2.1&#34; ), &#34;compile&#34; );        RemoteRepository central = new RemoteRepository.Builder( &#34;central&#34;, &#34;default&#34;, &#34;http://repo1.maven.org/maven2/&#34; ).build();        CollectRequest collectRequest = new CollectRequest();        collectRequest.setRoot( dependency );        collectRequest.addRepository( central );        DependencyNode node = repoSystem.collectDependencies( session, collectRequest ).getRoot();        DependencyRequest dependencyRequest = new DependencyRequest();        dependencyRequest.setRoot( node );        repoSystem.resolveDependencies( session, dependencyRequest  );        PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();        node.accept( nlg );        System.out.println( nlg.getClassPath() );    }</code></pre><p>运行后，便可在设置的本地仓库(Local Repository)文件夹下找到已下载的依赖库文件。</p><p>具体代码的内容也很清晰易懂：<br/>首先，Factory完成的是仓库连接与传输、本地仓库缓存的配置设置；</p><p>在main()方法内，初始化system(Repository系统及其功能的主要入口点)以及session(定义控制Repository系统的设置和组件)，再创建一个Dependency(需要下载的依赖)；</p><p>依赖必定需要从MavenRepository内查找，所以我们还需要RemoteRepository作为指定的远程仓库(注意：RemoteRepository可以同时添加多个，会依次查找)；</p><p>进行Dependency的下载前，需要构建其依赖关系树，以下载其及其所需子依赖，构建依赖关系树前需要查询，则下一步进行的是CollectRequest，设置其rootDependency为所需依赖(必定为依赖树的root)，并添加需要查找的RemoteRepository；</p><p>下一步即为依赖树的构建，repoSystem.collectDependencies()获取DependencyResult,再调用DependencyResult.getRoot()获取树的根节点，得到依赖树；</p><p>DependencyRequest用于初始化一个Dependency下载请求，设置root为刚刚得到的依赖树根节点即可，调用RepositorySystem.resolveDependencies(session,dependencyRequest)即可进行下载工作。可能会比较疑惑下载到哪里了，实际上可以知道在newSystemSession()方法内，我们进行session的初始化时已经设置了LocalRepository作为本地仓库，即缓存文件存放位置。</p><p>Tips: 最后的PreorderNodeListGenerator实质上不会对依赖下载产生影响，只是官方提供的一个遍历依赖树的示例。</p><h2 id="Aether开发逻辑介绍"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#Aether%E5%BC%80%E5%8F%91%E9%80%BB%E8%BE%91%E4%BB%8B%E7%BB%8D" class="headerlink" title="Aether开发逻辑介绍"></a>Aether开发逻辑介绍</h2><p>API部分建议自行浏览Aether的源代码，只需要了解基本的开发逻辑，则根据名字以及注释很容易上手。</p><ul><li>Aether使用的是依赖注入(Dependency Injection)这一设计模式，在使用RepositorySystem之前，必须从DefaultServiceLocator中进行初始化。DefaultServiceLocator在初始化时便以默认配置了需要类，我们按需添加缺失的必要类即可。在完成配置之后，Aether会通过DefaultServiceLocator.getService()方法得到需要的interface(当然是已经实例化的)，所以我们可以通过addService()在不修改Aether代码的情况下，更改一些核心逻辑，实现高度的自定义化；同时需要强调的是，我们也应该通过DefaultServiceLocator.getService()进行所需interface的获取。</li><li>Aether的所有操作基本上都是先创建一个XxxRequest，然后通过System执行对应的操作逻辑，结果是返回一个XxxResult。例如，Get Started代码中main()方法内的CollectRequest和DependencyRequest。且XxxRequest为Final Class，自行初始化即可。</li><li>特别注意，RepositorySystem需要通过DefaultServiceLocator得到的，通过依赖注入，RepositorySystem会自动获取DefaultServiceLocator中所需要的类；RepositorySystemSession则是配置信息的载体，需要自己通过代码设置配置信息。</li></ul><h2 id="常见操作需求"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E9%9C%80%E6%B1%82" class="headerlink" title="常见操作需求"></a>常见操作需求</h2><h3 id="下载Dependency"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E4%B8%8B%E8%BD%BDDependency" class="headerlink" title="下载Dependency"></a>下载Dependency</h3><p>见 <a href="https://xiue233.github.io/2023/09/09/aether-manual/#get-started">Get Started</a> 不再赘述。</p><h3 id="获取某一Artifact的缓存路径"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%80Artifact%E7%9A%84%E7%BC%93%E5%AD%98%E8%B7%AF%E5%BE%84" class="headerlink" title="获取某一Artifact的缓存路径"></a>获取某一Artifact的缓存路径</h3><ol><li>通过RepositorySystemSession.getLocalRepositoryManager()获取LocalRepositoryManager;</li><li>调用LocalRepositoryManager.getPathForLocalArtifact()</li></ol><h2 id="常见Model的初始化"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E5%B8%B8%E8%A7%81Model%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96" class="headerlink" title="常见Model的初始化"></a>常见Model的初始化</h2><ol><li>Artifact<br/>调用DefaultArtifact的构造方法即可，需要传入coords(坐标，诸如org.apache.maven:maven-profile:2.2.1格式)，也有其他构造方法，具体自行浏览API。</li><li>Dependency<br/>调用Dependency的构造方法，并传入Artifact及scope(<a href="https://www.baeldung.com/maven-dependency-scopes">Maven Scope</a>)等参数即可。</li></ol><h2 id="常见问题-已解决"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E5%B7%B2%E8%A7%A3%E5%86%B3" class="headerlink" title="常见问题(已解决)"></a>常见问题(已解决)</h2><h3 id="无法自动识别依赖文件类型为AAR的Artifact"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E6%97%A0%E6%B3%95%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E4%BE%9D%E8%B5%96%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%BAAAR%E7%9A%84Artifact" class="headerlink" title="无法自动识别依赖文件类型为AAR的Artifact"></a>无法自动识别依赖文件类型为AAR的Artifact</h3><p>因为我的初衷是用在android ide上，下载aar文件是不可避免的，但是从<code>org.eclipse.aether.artifact.DefaultArtifact</code>的构造方法可以看到(见下面的代码)，默认的extension是jar，并且extension是final修饰的。</p><pre><code class="java">...    public DefaultArtifact(String coords, Map&lt;String, String&gt; properties) {        Matcher m = COORDINATE_PATTERN.matcher(coords);        if (!m.matches()) {            throw new IllegalArgumentException(&#34;Bad artifact coordinates &#34; + coords                    + &#34;, expected format is &lt;groupId&gt;:&lt;artifactId&gt;[:&lt;extension&gt;[:&lt;classifier&gt;]]:&lt;version&gt;&#34;);        }        groupId = m.group(1);        artifactId = m.group(2);        extension = get(m.group(4), &#34;jar&#34;); //this line        classifier = get(m.group(6), &#34;&#34;);        version = m.group(7);        file = null;        this.properties = copyProperties(properties);    }...</code></pre><p>可能到这里会想，那就在coords里指明extension不就可以了吗？很遗憾，测试后，你会发现这个根依赖倒是下载了，但是其子依赖仍然无法正确的识别文件类型。</p><p>接下来我们从源码的层面分析一下：</p><p>首先，根据上文的研究，Collect阶段会进行依赖树的构建，我们以此为入口，分析子依赖的构建过程。需要注意的是interface对应的默认impl类为DefaultXxx，比如RepositorySystem对应的默认impl类为DefaultRepositorySystem。</p><pre><code class="java">package org.eclipse.aether.internal.impl;public class DefaultRepositorySystem implements RepositorySystem, Service {    ...    @Override    public CollectResult collectDependencies(RepositorySystemSession session, CollectRequest request)            throws DependencyCollectionException {        validateSession(session);        requireNonNull(request, &#34;request cannot be null&#34;);        return dependencyCollector.collectDependencies(session, request);    }    ...}</code></pre><p>可以看到dependencyCollector.collectDependencies()执行了具体的操作，从dependencyCollector的初始化代码以及DefaultServiceLocator的相关代码，得知默认impl类为org.eclipse.aether.internal.impl.collect.DefaultDependencyCollector，继续往下追踪。</p><pre><code class="java">public class DefaultDependencyCollector implements DependencyCollector, Service {    ...    @Override    public CollectResult collectDependencies(RepositorySystemSession session, CollectRequest request)            throws DependencyCollectionException {        String delegateName = ConfigUtils.getString(session, DEFAULT_COLLECTOR_IMPL, CONFIG_PROP_COLLECTOR_IMPL);        DependencyCollectorDelegate delegate = delegates.get(delegateName);        if (delegate == null) {            throw new IllegalArgumentException(                    &#34;Unknown collector impl: &#39;&#34; + delegateName + &#34;&#39;, known implementations are &#34; + delegates.keySet());        }        return delegate.collectDependencies(session, request);    }    ...}</code></pre><p>好好好，继续套娃操作，看代码知默认是深度优先<code>org.eclipse.aether.internal.impl.collect.df.DfDependencyCollector</code>，并且DependencyCollectorDelegate会利用collectDependencies()包装了DependencyCollector.doCollectDependencies()方法。</p><pre><code class="java">public abstract class DependencyCollectorDelegate implements DependencyCollector {    ...    @Override    public final CollectResult collectDependencies(RepositorySystemSession session, CollectRequest request)            throws DependencyCollectionException {        requireNonNull(session, &#34;session cannot be null&#34;);        requireNonNull(request, &#34;request cannot be null&#34;);        session = optimizeSession(session);        RequestTrace trace = RequestTrace.newChild(request.getTrace(), request);        CollectResult result = new CollectResult(request);        DependencyTraverser depTraverser = session.getDependencyTraverser();        VersionFilter verFilter = session.getVersionFilter();        Dependency root = request.getRoot();        List&lt;RemoteRepository&gt; repositories = request.getRepositories();        List&lt;Dependency&gt; dependencies = request.getDependencies();        List&lt;Dependency&gt; managedDependencies = request.getManagedDependencies();        Map&lt;String, Object&gt; stats = new LinkedHashMap&lt;&gt;();        long time1 = System.nanoTime();        DefaultDependencyNode node;        if (root != null) {            List&lt;? extends Version&gt; versions;            VersionRangeResult rangeResult;            try {                VersionRangeRequest rangeRequest = new VersionRangeRequest(                        root.getArtifact(), request.getRepositories(), request.getRequestContext());                rangeRequest.setTrace(trace);                rangeResult = versionRangeResolver.resolveVersionRange(session, rangeRequest);                versions = filterVersions(root, rangeResult, verFilter, new DefaultVersionFilterContext(session));            } catch (VersionRangeResolutionException e) {                result.addException(e);                throw new DependencyCollectionException(result, e.getMessage());            }            Version version = versions.get(versions.size() - 1);            root = root.setArtifact(root.getArtifact().setVersion(version.toString()));            ArtifactDescriptorResult descriptorResult; //关键代码            try {                ArtifactDescriptorRequest descriptorRequest = new ArtifactDescriptorRequest();                descriptorRequest.setArtifact(root.getArtifact());                descriptorRequest.setRepositories(request.getRepositories());                descriptorRequest.setRequestContext(request.getRequestContext());                descriptorRequest.setTrace(trace);                if (isLackingDescriptor(root.getArtifact())) {                    descriptorResult = new ArtifactDescriptorResult(descriptorRequest);                } else {                    descriptorResult = descriptorReader.readArtifactDescriptor(session, descriptorRequest);                }            } catch (ArtifactDescriptorException e) {                result.addException(e);                throw new DependencyCollectionException(result, e.getMessage());            }            root = root.setArtifact(descriptorResult.getArtifact());            if (!session.isIgnoreArtifactDescriptorRepositories()) {                repositories = remoteRepositoryManager.aggregateRepositories(                        session, repositories, descriptorResult.getRepositories(), true);            }            dependencies = mergeDeps(dependencies, descriptorResult.getDependencies());            managedDependencies = mergeDeps(managedDependencies, descriptorResult.getManagedDependencies());            node = new DefaultDependencyNode(root);            node.setRequestContext(request.getRequestContext());            node.setRelocations(descriptorResult.getRelocations());            node.setVersionConstraint(rangeResult.getVersionConstraint());            node.setVersion(version);            node.setAliases(descriptorResult.getAliases());            node.setRepositories(request.getRepositories());        } else {            node = new DefaultDependencyNode(request.getRootArtifact());            node.setRequestContext(request.getRequestContext());            node.setRepositories(request.getRepositories());        }        result.setRoot(node);        boolean traverse = root == null || depTraverser == null || depTraverser.traverseDependency(root);        String errorPath = null;        if (traverse &amp;&amp; !dependencies.isEmpty()) {            DataPool pool = new DataPool(session);            DefaultDependencyCollectionContext context = new DefaultDependencyCollectionContext(                    session, request.getRootArtifact(), root, managedDependencies);            DefaultVersionFilterContext versionContext = new DefaultVersionFilterContext(session);            Results results = new Results(result, session);            doCollectDependencies(                    session,                    trace,                    pool,                    context,                    versionContext,                    request,                    node,                    repositories,                    dependencies,                    managedDependencies,                    results);            errorPath = results.getErrorPath();        }        long time2 = System.nanoTime();        DependencyGraphTransformer transformer = session.getDependencyGraphTransformer();        if (transformer != null) {            try {                DefaultDependencyGraphTransformationContext context =                        new DefaultDependencyGraphTransformationContext(session);                context.put(TransformationContextKeys.STATS, stats);                result.setRoot(transformer.transformGraph(node, context));            } catch (RepositoryException e) {                result.addException(e);            }        }        long time3 = System.nanoTime();        if (logger.isDebugEnabled()) {            stats.put(getClass().getSimpleName() + &#34;.collectTime&#34;, time2 - time1);            stats.put(getClass().getSimpleName() + &#34;.transformTime&#34;, time3 - time2);            logger.debug(&#34;Dependency collection stats {}&#34;, stats);        }        if (errorPath != null) {            throw new DependencyCollectionException(result, &#34;Failed to collect dependencies at &#34; + errorPath);        }        if (!result.getExceptions().isEmpty()) {            throw new DependencyCollectionException(result);        }        return result;    }    ...}</code></pre><pre><code class="java">public class DfDependencyCollector extends DependencyCollectorDelegate implements Service {    ...    @Override    protected void doCollectDependencies(            RepositorySystemSession session,            RequestTrace trace,            DataPool pool,            DefaultDependencyCollectionContext context,            DefaultVersionFilterContext versionContext,            CollectRequest request,            DependencyNode node,            List&lt;RemoteRepository&gt; repositories,            List&lt;Dependency&gt; dependencies,            List&lt;Dependency&gt; managedDependencies,            Results results) {        NodeStack nodes = new NodeStack();        nodes.push(node);        Args args = new Args(session, pool, nodes, context, versionContext, request);        process(                args,                trace,                results,                dependencies,                repositories,                session.getDependencySelector() != null                        ? session.getDependencySelector().deriveChildSelector(context)                        : null,                session.getDependencyManager() != null                        ? session.getDependencyManager().deriveChildManager(context)                        : null,                session.getDependencyTraverser() != null                        ? session.getDependencyTraverser().deriveChildTraverser(context)                        : null,                session.getVersionFilter() != null ? session.getVersionFilter().deriveChildFilter(context) : null);    }    private void process(            final Args args,            RequestTrace trace,            Results results,            List&lt;Dependency&gt; dependencies,            List&lt;RemoteRepository&gt; repositories,            DependencySelector depSelector,            DependencyManager depManager,            DependencyTraverser depTraverser,            VersionFilter verFilter) {        for (Dependency dependency : dependencies) {            processDependency(                    args, trace, results, repositories, depSelector, depManager, depTraverser, verFilter, dependency);        }    }    private void processDependency(            Args args,            RequestTrace trace,            Results results,            List&lt;RemoteRepository&gt; repositories,            DependencySelector depSelector,            DependencyManager depManager,            DependencyTraverser depTraverser,            VersionFilter verFilter,            Dependency dependency) {        List&lt;Artifact&gt; relocations = Collections.emptyList();        processDependency(                args,                trace,                results,                repositories,                depSelector,                depManager,                depTraverser,                verFilter,                dependency,                relocations,                false);    }    private void processDependency(            Args args,            RequestTrace parent,            Results results,            List&lt;RemoteRepository&gt; repositories,            DependencySelector depSelector,            DependencyManager depManager,            DependencyTraverser depTraverser,            VersionFilter verFilter,            Dependency dependency,            List&lt;Artifact&gt; relocations,            boolean disableVersionManagement) {        if (depSelector != null &amp;&amp; !depSelector.selectDependency(dependency)) {            return;        }        RequestTrace trace = collectStepTrace(parent, args.request.getRequestContext(), args.nodes.nodes, dependency);        PremanagedDependency preManaged =                PremanagedDependency.create(depManager, dependency, disableVersionManagement, args.premanagedState);        dependency = preManaged.getManagedDependency();        boolean noDescriptor = isLackingDescriptor(dependency.getArtifact());        boolean traverse = !noDescriptor &amp;&amp; (depTraverser == null || depTraverser.traverseDependency(dependency));        List&lt;? extends Version&gt; versions;        VersionRangeResult rangeResult;        try {            VersionRangeRequest rangeRequest =                    createVersionRangeRequest(args.request.getRequestContext(), trace, repositories, dependency);            rangeResult = cachedResolveRangeResult(rangeRequest, args.pool, args.session);            versions = filterVersions(dependency, rangeResult, verFilter, args.versionContext);        } catch (VersionRangeResolutionException e) {            results.addException(dependency, e, args.nodes.nodes);            return;        }        for (Version version : versions) {            Artifact originalArtifact = dependency.getArtifact().setVersion(version.toString());            Dependency d = dependency.setArtifact(originalArtifact);            ArtifactDescriptorRequest descriptorRequest =                    createArtifactDescriptorRequest(args.request.getRequestContext(), trace, repositories, d);//关键代码            final ArtifactDescriptorResult descriptorResult =                    getArtifactDescriptorResult(args, results, noDescriptor, d, descriptorRequest);//关键代码            if (descriptorResult != null) {                d = d.setArtifact(descriptorResult.getArtifact());                DependencyNode node = args.nodes.top();                int cycleEntry = DefaultDependencyCycle.find(args.nodes.nodes, d.getArtifact());                if (cycleEntry &gt;= 0) {                    results.addCycle(args.nodes.nodes, cycleEntry, d);                    DependencyNode cycleNode = args.nodes.get(cycleEntry);                    if (cycleNode.getDependency() != null) {                        DefaultDependencyNode child = createDependencyNode(                                relocations, preManaged, rangeResult, version, d, descriptorResult, cycleNode);                        node.getChildren().add(child);                        continue;                    }                }                if (!descriptorResult.getRelocations().isEmpty()) {                    boolean disableVersionManagementSubsequently =                            originalArtifact.getGroupId().equals(d.getArtifact().getGroupId())                                    &amp;&amp; originalArtifact                                            .getArtifactId()                                            .equals(d.getArtifact().getArtifactId());                    processDependency(                            args,                            parent,                            results,                            repositories,                            depSelector,                            depManager,                            depTraverser,                            verFilter,                            d,                            descriptorResult.getRelocations(),                            disableVersionManagementSubsequently);                    return;                } else {                    d = args.pool.intern(d.setArtifact(args.pool.intern(d.getArtifact())));                    List&lt;RemoteRepository&gt; repos =                            getRemoteRepositories(rangeResult.getRepository(version), repositories);                    DefaultDependencyNode child = createDependencyNode(                            relocations,                            preManaged,                            rangeResult,                            version,                            d,                            descriptorResult.getAliases(),                            repos,                            args.request.getRequestContext());                    node.getChildren().add(child);                    boolean recurse =                            traverse &amp;&amp; !descriptorResult.getDependencies().isEmpty();                    if (recurse) {                        doRecurse(                                args,                                parent,                                results,                                repositories,                                depSelector,                                depManager,                                depTraverser,                                verFilter,                                d,                                descriptorResult,                                child);                    }                }            } else {                DependencyNode node = args.nodes.top();                List&lt;RemoteRepository&gt; repos = getRemoteRepositories(rangeResult.getRepository(version), repositories);                DefaultDependencyNode child = createDependencyNode(                        relocations,                        preManaged,                        rangeResult,                        version,                        d,                        null,                        repos,                        args.request.getRequestContext());                node.getChildren().add(child);            }        }    }    ...}</code></pre><p>代码中已用注释写明了关键代码位置，可以得知在RootDependency的Collect操作中，会进行ArtifactDescriptor(即，依赖的pom文件的解析)的解析操作，得到该Dependency的直接依赖，此操作由ArtifactDescriptorReader进行，但是既然解析了pom文件，为什么不根据pom文件内声明的extension类型来修正Artifact对应的文件类型呢？只因<del>你太美</del>Artifact中的extension是final修饰的，咱也不懂Aether为什么不写个自动修正extension的操作，毕竟人家是apache foundation下的，咱也不敢问。</p><h4 id="解决方法"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95" class="headerlink" title="解决方法"></a>解决方法</h4><p>前情回顾，Aether内部使用了Dependency Injection，我们如果需要更改内部的逻辑，最简单的当然还是利用DefaultLocatorService操作了。</p><p>我们只需这么修改代码，将默认的ArtifactDescriptorReader更改为可以自动修正的自定义ArtifactDescriptorReader即可:</p><pre><code class="java">...    public static RepositorySystem newRepositorySystem() {        DefaultServiceLocator locator = new DefaultServiceLocator();//        locator.addService(ArtifactDescriptorReader.class, DefaultArtifactDescriptorReader.class); //默认的ArtifactDescriptorReader        locator.addService(ArtifactDescriptorReader.class, CompactAARArtifactDescriptorReader.class);//兼容AAR的CompactAARArtifactDescriptorReader        locator.addService(VersionResolver.class, DefaultVersionResolver.class);        locator.addService(VersionRangeResolver.class, DefaultVersionRangeResolver.class);        locator.addService(MetadataGeneratorFactory.class, SnapshotMetadataGeneratorFactory.class);        locator.addService(MetadataGeneratorFactory.class, VersionsMetadataGeneratorFactory.class);        locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);        locator.addService(TransporterFactory.class, FileTransporterFactory.class);        locator.addService(TransporterFactory.class, HttpTransporterFactory.class);        return locator.getService(RepositorySystem.class);    }...</code></pre><p>这个思路显然是对的，但是问题又来了，我们如何实现自动修正，毕竟人家extension是final修饰的？反射操作。</p><p>那，又怎么获取正确的extension呢？不妨来看看ArtifactDescriptorReader的代码，看看人家是怎么解析的。</p><p><code>org.apache.maven.repository.internal.DefaultArtifactDescriptorReader</code>的代码摘要(具体片段懒得继续缩减了，就这个方法先凑活看好了):</p><pre><code class="java">public class DefaultArtifactDescriptorReader    implements ArtifactDescriptorReader, Service{    ...    private Model loadPom( RepositorySystemSession session, ArtifactDescriptorRequest request,                           ArtifactDescriptorResult result )        throws ArtifactDescriptorException    {        RequestTrace trace = RequestTrace.newChild( request.getTrace(), request );        Set&lt;String&gt; visited = new LinkedHashSet&lt;String&gt;();        for ( Artifact artifact = request.getArtifact();; )        {            try            {                VersionRequest versionRequest =                    new VersionRequest( artifact, request.getRepositories(), request.getRequestContext() );                versionRequest.setTrace( trace );                VersionResult versionResult = versionResolver.resolveVersion( session, versionRequest );                artifact = artifact.setVersion( versionResult.getVersion() );            }            catch ( VersionResolutionException e )            {                result.addException( e );                throw new ArtifactDescriptorException( result );            }            if ( !visited.add( artifact.getGroupId() + &#39;:&#39; + artifact.getArtifactId() + &#39;:&#39; + artifact.getBaseVersion() ) )            {                RepositoryException exception =                    new RepositoryException( &#34;Artifact relocations form a cycle: &#34; + visited );                invalidDescriptor( session, trace, artifact, exception );                if ( ( getPolicy( session, artifact, request ) &amp; ArtifactDescriptorPolicy.IGNORE_INVALID ) != 0 )                {                    return null;                }                result.addException( exception );                throw new ArtifactDescriptorException( result );            }            Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact( artifact );            ArtifactResult resolveResult;            try            {                ArtifactRequest resolveRequest =                    new ArtifactRequest( pomArtifact, request.getRepositories(), request.getRequestContext() );                resolveRequest.setTrace( trace );                resolveResult = artifactResolver.resolveArtifact( session, resolveRequest );                pomArtifact = resolveResult.getArtifact();                result.setRepository( resolveResult.getRepository() );            }            catch ( ArtifactResolutionException e )            {                if ( e.getCause() instanceof ArtifactNotFoundException )                {                    missingDescriptor( session, trace, artifact, (Exception) e.getCause() );                    if ( ( getPolicy( session, artifact, request ) &amp; ArtifactDescriptorPolicy.IGNORE_MISSING ) != 0 )                    {                        return null;                    }                }                result.addException( e );                throw new ArtifactDescriptorException( result );            }            Model model;// Model为POM文件对应的模型类            try            {                ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();                modelRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );                modelRequest.setProcessPlugins( false );                modelRequest.setTwoPhaseBuilding( false );                modelRequest.setSystemProperties( toProperties( session.getUserProperties(),                                                                session.getSystemProperties() ) );                modelRequest.setModelCache( DefaultModelCache.newInstance( session ) );                modelRequest.setModelResolver( new DefaultModelResolver( session, trace.newChild( modelRequest ),                                                                         request.getRequestContext(), artifactResolver,                                                                         remoteRepositoryManager,                                                                         request.getRepositories() ) );                if ( resolveResult.getRepository() instanceof WorkspaceRepository )                {                    modelRequest.setPomFile( pomArtifact.getFile() );                }                else                {                    modelRequest.setModelSource( new FileModelSource( pomArtifact.getFile() ) );                }                model = modelBuilder.build( modelRequest ).getEffectiveModel();            }            catch ( ModelBuildingException e )            {                for ( ModelProblem problem : e.getProblems() )                {                    if ( problem.getException() instanceof UnresolvableModelException )                    {                        result.addException( problem.getException() );                        throw new ArtifactDescriptorException( result );                    }                }                invalidDescriptor( session, trace, artifact, e );                if ( ( getPolicy( session, artifact, request ) &amp; ArtifactDescriptorPolicy.IGNORE_INVALID ) != 0 )                {                    return null;                }                result.addException( e );                throw new ArtifactDescriptorException( result );            }            Relocation relocation = getRelocation( model );            if ( relocation != null )            {                result.addRelocation( artifact );                artifact =                    new RelocatedArtifact( artifact, relocation.getGroupId(), relocation.getArtifactId(),                                           relocation.getVersion() );                result.setArtifact( artifact );            }            else            {                return model;            }        }    }    ...}</code></pre><p>上面的loadPom()方法会在DefaultArtifactDescriptorReader.readArtifactDescriptor()中调用，代码中的<code>org.apache.maven.model.Model</code>类是POM文件的模型类，我们可以调用Model.getPackaging()获得extension，并且loadPom()接受一个ArtifactDescriptorResult参数，我们可以通过ArtifactDescriptorResult.getArtifact()取得当前操作的Artifact以更正extension字段。</p><blockquote><p>Q：为什么我不使用setArtifact()方法来替换Artifact？<br/>A：因为，lazy不想再实验了，并且用反射得到的程序可以正常运行(逃)。如果感兴趣可以自己试试</p></blockquote><p><strong>注意：代码中存在internal的类，我们不能在自己项目内直接调用，所以再加一层反射操作来替换这些操作internal的类即可。</strong></p><p>CompactAARArtifactDescriptorReader代码如下(随手写的，建议用者再仔细看看，另外Reflect为团队内的反射工具，自己替换为正常的反射代码即可)：</p><pre><code class="java">import org.apache.maven.model.DependencyManagement;import org.apache.maven.model.DistributionManagement;import org.apache.maven.model.License;import org.apache.maven.model.Model;import org.apache.maven.model.Prerequisites;import org.apache.maven.model.Relocation;import org.apache.maven.model.Repository;import org.apache.maven.model.building.DefaultModelBuilderFactory;import org.apache.maven.model.building.DefaultModelBuildingRequest;import org.apache.maven.model.building.FileModelSource;import org.apache.maven.model.building.ModelBuilder;import org.apache.maven.model.building.ModelBuildingException;import org.apache.maven.model.building.ModelBuildingRequest;import org.apache.maven.model.building.ModelProblem;import org.apache.maven.model.resolution.UnresolvableModelException;import org.apache.maven.repository.internal.ArtifactDescriptorUtils;import org.codehaus.plexus.component.annotations.Component;import org.codehaus.plexus.component.annotations.Requirement;import org.eclipse.aether.RepositoryEvent;import org.eclipse.aether.RepositoryEvent.EventType;import org.eclipse.aether.RepositoryException;import org.eclipse.aether.RepositorySystemSession;import org.eclipse.aether.RequestTrace;import org.eclipse.aether.artifact.Artifact;import org.eclipse.aether.artifact.ArtifactProperties;import org.eclipse.aether.artifact.ArtifactType;import org.eclipse.aether.artifact.ArtifactTypeRegistry;import org.eclipse.aether.artifact.DefaultArtifact;import org.eclipse.aether.artifact.DefaultArtifactType;import org.eclipse.aether.graph.Dependency;import org.eclipse.aether.graph.Exclusion;import org.eclipse.aether.impl.ArtifactDescriptorReader;import org.eclipse.aether.impl.ArtifactResolver;import org.eclipse.aether.impl.RemoteRepositoryManager;import org.eclipse.aether.impl.RepositoryEventDispatcher;import org.eclipse.aether.impl.VersionResolver;import org.eclipse.aether.repository.WorkspaceRepository;import org.eclipse.aether.resolution.ArtifactDescriptorException;import org.eclipse.aether.resolution.ArtifactDescriptorPolicy;import org.eclipse.aether.resolution.ArtifactDescriptorPolicyRequest;import org.eclipse.aether.resolution.ArtifactDescriptorRequest;import org.eclipse.aether.resolution.ArtifactDescriptorResult;import org.eclipse.aether.resolution.ArtifactRequest;import org.eclipse.aether.resolution.ArtifactResolutionException;import org.eclipse.aether.resolution.ArtifactResult;import org.eclipse.aether.resolution.VersionRequest;import org.eclipse.aether.resolution.VersionResolutionException;import org.eclipse.aether.resolution.VersionResult;import org.eclipse.aether.spi.locator.Service;import org.eclipse.aether.spi.locator.ServiceLocator;import org.eclipse.aether.spi.log.Logger;import org.eclipse.aether.spi.log.LoggerFactory;import org.eclipse.aether.spi.log.NullLoggerFactory;import org.eclipse.aether.transfer.ArtifactNotFoundException;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;import javax.inject.Inject;import javax.inject.Named;@Named@Component(role = ArtifactDescriptorReader.class)public class CompactAARArtifactDescriptorReader        implements ArtifactDescriptorReader, Service {    @SuppressWarnings(&#34;unused&#34;)    @Requirement(role = LoggerFactory.class)    private Logger logger = NullLoggerFactory.LOGGER;    @Requirement    private RemoteRepositoryManager remoteRepositoryManager;    @Requirement    private VersionResolver versionResolver;    @Requirement    private ArtifactResolver artifactResolver;    @Requirement    private RepositoryEventDispatcher repositoryEventDispatcher;    @Requirement    private ModelBuilder modelBuilder;    public CompactAARArtifactDescriptorReader() {        // enable no-arg constructor    }    @Inject    CompactAARArtifactDescriptorReader(RemoteRepositoryManager remoteRepositoryManager, VersionResolver versionResolver,                                       ArtifactResolver artifactResolver, ModelBuilder modelBuilder,                                       RepositoryEventDispatcher repositoryEventDispatcher, LoggerFactory loggerFactory) {        setRemoteRepositoryManager(remoteRepositoryManager);        setVersionResolver(versionResolver);        setArtifactResolver(artifactResolver);        setModelBuilder(modelBuilder);        setLoggerFactory(loggerFactory);        setRepositoryEventDispatcher(repositoryEventDispatcher);    }    public void initService(ServiceLocator locator) {        setLoggerFactory(locator.getService(LoggerFactory.class));        setRemoteRepositoryManager(locator.getService(RemoteRepositoryManager.class));        setVersionResolver(locator.getService(VersionResolver.class));        setArtifactResolver(locator.getService(ArtifactResolver.class));        setRepositoryEventDispatcher(locator.getService(RepositoryEventDispatcher.class));        modelBuilder = locator.getService(ModelBuilder.class);        if (modelBuilder == null) {            setModelBuilder(new DefaultModelBuilderFactory().newInstance());        }    }    public CompactAARArtifactDescriptorReader setLoggerFactory(LoggerFactory loggerFactory) {        this.logger = NullLoggerFactory.getSafeLogger(loggerFactory, getClass());        return this;    }    void setLogger(LoggerFactory loggerFactory) {        // plexus support        setLoggerFactory(loggerFactory);    }    public CompactAARArtifactDescriptorReader setRemoteRepositoryManager(RemoteRepositoryManager remoteRepositoryManager) {        if (remoteRepositoryManager == null) {            throw new IllegalArgumentException(&#34;remote repository manager has not been specified&#34;);        }        this.remoteRepositoryManager = remoteRepositoryManager;        return this;    }    public CompactAARArtifactDescriptorReader setVersionResolver(VersionResolver versionResolver) {        if (versionResolver == null) {            throw new IllegalArgumentException(&#34;version resolver has not been specified&#34;);        }        this.versionResolver = versionResolver;        return this;    }    public CompactAARArtifactDescriptorReader setArtifactResolver(ArtifactResolver artifactResolver) {        if (artifactResolver == null) {            throw new IllegalArgumentException(&#34;artifact resolver has not been specified&#34;);        }        this.artifactResolver = artifactResolver;        return this;    }    public CompactAARArtifactDescriptorReader setRepositoryEventDispatcher(RepositoryEventDispatcher repositoryEventDispatcher) {        if (repositoryEventDispatcher == null) {            throw new IllegalArgumentException(&#34;repository event dispatcher has not been specified&#34;);        }        this.repositoryEventDispatcher = repositoryEventDispatcher;        return this;    }    public CompactAARArtifactDescriptorReader setModelBuilder(ModelBuilder modelBuilder) {        if (modelBuilder == null) {            throw new IllegalArgumentException(&#34;model builder has not been specified&#34;);        }        this.modelBuilder = modelBuilder;        return this;    }    public ArtifactDescriptorResult readArtifactDescriptor(RepositorySystemSession session,                                                           ArtifactDescriptorRequest request)            throws ArtifactDescriptorException {        ArtifactDescriptorResult result = new ArtifactDescriptorResult(request);        Model model = loadPom(session, request, result);        if (model != null) {            ArtifactTypeRegistry stereotypes = session.getArtifactTypeRegistry();            for (Repository r : model.getRepositories()) {                result.addRepository(ArtifactDescriptorUtils.toRemoteRepository(r));            }            for (org.apache.maven.model.Dependency dependency : model.getDependencies()) {                result.addDependency(convert(dependency, stereotypes));            }            DependencyManagement mngt = model.getDependencyManagement();            if (mngt != null) {                for (org.apache.maven.model.Dependency dependency : mngt.getDependencies()) {                    result.addManagedDependency(convert(dependency, stereotypes));                }            }            Map&lt;String, Object&gt; properties = new LinkedHashMap&lt;String, Object&gt;();            Prerequisites prerequisites = model.getPrerequisites();            if (prerequisites != null) {                properties.put(&#34;prerequisites.maven&#34;, prerequisites.getMaven());            }            List&lt;License&gt; licenses = model.getLicenses();            properties.put(&#34;license.count&#34;, licenses.size());            for (int i = 0; i &lt; licenses.size(); i++) {                License license = licenses.get(i);                properties.put(&#34;license.&#34; + i + &#34;.name&#34;, license.getName());                properties.put(&#34;license.&#34; + i + &#34;.url&#34;, license.getUrl());                properties.put(&#34;license.&#34; + i + &#34;.comments&#34;, license.getComments());                properties.put(&#34;license.&#34; + i + &#34;.distribution&#34;, license.getDistribution());            }            result.setProperties(properties);            setArtifactProperties(result, model);        }        return result;    }    private Model loadPom(RepositorySystemSession session, ArtifactDescriptorRequest request,                          ArtifactDescriptorResult result)            throws ArtifactDescriptorException {        RequestTrace trace = RequestTrace.newChild(request.getTrace(), request);        Set&lt;String&gt; visited = new LinkedHashSet&lt;String&gt;();        for (Artifact artifact = request.getArtifact(); ; ) {            try {                VersionRequest versionRequest =                        new VersionRequest(artifact, request.getRepositories(), request.getRequestContext());                versionRequest.setTrace(trace);                VersionResult versionResult = versionResolver.resolveVersion(session, versionRequest);                artifact = artifact.setVersion(versionResult.getVersion());            } catch (VersionResolutionException e) {                result.addException(e);                throw new ArtifactDescriptorException(result);            }            if (!visited.add(artifact.getGroupId() + &#39;:&#39; + artifact.getArtifactId() + &#39;:&#39; + artifact.getBaseVersion())) {                RepositoryException exception =                        new RepositoryException(&#34;Artifact relocations form a cycle: &#34; + visited);                invalidDescriptor(session, trace, artifact, exception);                if ((getPolicy(session, artifact, request) &amp; ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {                    return null;                }                result.addException(exception);                throw new ArtifactDescriptorException(result);            }            Artifact pomArtifact = ArtifactDescriptorUtils.toPomArtifact(artifact);            ArtifactResult resolveResult;            try {                ArtifactRequest resolveRequest =                        new ArtifactRequest(pomArtifact, request.getRepositories(), request.getRequestContext());                resolveRequest.setTrace(trace);                resolveResult = artifactResolver.resolveArtifact(session, resolveRequest);                pomArtifact = resolveResult.getArtifact();                result.setRepository(resolveResult.getRepository());            } catch (ArtifactResolutionException e) {                if (e.getCause() instanceof ArtifactNotFoundException) {                    missingDescriptor(session, trace, artifact, (Exception) e.getCause());                    if ((getPolicy(session, artifact, request) &amp; ArtifactDescriptorPolicy.IGNORE_MISSING) != 0) {                        return null;                    }                }                result.addException(e);                throw new ArtifactDescriptorException(result);            }            Model model;            try {                ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();                modelRequest.setValidationLevel(ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL);                modelRequest.setProcessPlugins(false);                modelRequest.setTwoPhaseBuilding(false);                modelRequest.setSystemProperties(toProperties(session.getUserProperties(),                        session.getSystemProperties()));                modelRequest.setModelCache(                        Reflect.on(&#34;org.apache.maven.repository.internal.DefaultModelCache&#34;)                                .call(&#34;newInstance&#34;, session).get());                //modelRequest.setModelCache( DefaultModelCache.newInstance( session ) );                modelRequest.setModelResolver(                        Reflect.on(&#34;org.apache.maven.repository.internal.DefaultModelResolver&#34;)                                .create(session, trace.newChild(modelRequest),                                        request.getRequestContext(), artifactResolver,                                        remoteRepositoryManager,                                        request.getRepositories())                                .get());//              modelRequest.setModelResolver(new DefaultModelResolver(session, trace.newChild(modelRequest),//                        request.getRequestContext(), artifactResolver,//                        remoteRepositoryManager,//                        request.getRepositories()));                if (resolveResult.getRepository() instanceof WorkspaceRepository) {                    modelRequest.setPomFile(pomArtifact.getFile());                } else {                    modelRequest.setModelSource(new FileModelSource(pomArtifact.getFile()));                }                model = modelBuilder.build(modelRequest).getEffectiveModel();            } catch (ModelBuildingException e) {                for (ModelProblem problem : e.getProblems()) {                    if (problem.getException() instanceof UnresolvableModelException) {                        result.addException(problem.getException());                        throw new ArtifactDescriptorException(result);                    }                }                invalidDescriptor(session, trace, artifact, e);                if ((getPolicy(session, artifact, request) &amp; ArtifactDescriptorPolicy.IGNORE_INVALID) != 0) {                    return null;                }                result.addException(e);                throw new ArtifactDescriptorException(result);            }            Relocation relocation = getRelocation(model);            String packaging = model.getPackaging();            if (&#34;aar&#34;.equals(packaging)) { //适配aar类型                //根据POM重置artifact的extenstion                try {                    Class&lt;DefaultArtifact&gt; artifactCls = DefaultArtifact.class;                    Field extension = artifactCls.getDeclaredField(&#34;extension&#34;);                    extension.setAccessible(true);                    extension.set(result.getArtifact(), model.getPackaging());                } catch (Exception e) {                    e.printStackTrace();                }            }            if (relocation != null) {                result.addRelocation(artifact);                artifact = Reflect.on(&#34;org.apache.maven.repository.internal.RelocatedArtifact&#34;)                        .create(artifact, relocation.getGroupId(), relocation.getArtifactId(),                                relocation.getVersion()).get();//                artifact =//                        new RelocatedArtifact(artifact, relocation.getGroupId(), relocation.getArtifactId(),//                                relocation.getVersion());                result.setArtifact(artifact);            } else {                return model;            }        }    }    private Properties toProperties(Map&lt;String, String&gt; dominant, Map&lt;String, String&gt; recessive) {        Properties props = new Properties();        if (recessive != null) {            props.putAll(recessive);        }        if (dominant != null) {            props.putAll(dominant);        }        return props;    }    private Relocation getRelocation(Model model) {        Relocation relocation = null;        DistributionManagement distMngt = model.getDistributionManagement();        if (distMngt != null) {            relocation = distMngt.getRelocation();        }        return relocation;    }    private void setArtifactProperties(ArtifactDescriptorResult result, Model model) {        String downloadUrl = null;        DistributionManagement distMngt = model.getDistributionManagement();        if (distMngt != null) {            downloadUrl = distMngt.getDownloadUrl();        }        if (downloadUrl != null &amp;&amp; downloadUrl.length() &gt; 0) {            Artifact artifact = result.getArtifact();            Map&lt;String, String&gt; props = new HashMap&lt;String, String&gt;(artifact.getProperties());            props.put(ArtifactProperties.DOWNLOAD_URL, downloadUrl);            result.setArtifact(artifact.setProperties(props));        }    }    private Dependency convert(org.apache.maven.model.Dependency dependency, ArtifactTypeRegistry stereotypes) {        ArtifactType stereotype = stereotypes.get(dependency.getType());        if (stereotype == null) {            stereotype = new DefaultArtifactType(dependency.getType());        }        boolean system = dependency.getSystemPath() != null &amp;&amp; dependency.getSystemPath().length() &gt; 0;        Map&lt;String, String&gt; props = null;        if (system) {            props = Collections.singletonMap(ArtifactProperties.LOCAL_PATH, dependency.getSystemPath());        }        Artifact artifact =                new DefaultArtifact(dependency.getGroupId(), dependency.getArtifactId(), dependency.getClassifier(), null,                        dependency.getVersion(), props, stereotype);        List&lt;Exclusion&gt; exclusions = new ArrayList&lt;Exclusion&gt;(dependency.getExclusions().size());        for (org.apache.maven.model.Exclusion exclusion : dependency.getExclusions()) {            exclusions.add(convert(exclusion));        }        Dependency result = new Dependency(artifact, dependency.getScope(), dependency.isOptional(), exclusions);        return result;    }    private Exclusion convert(org.apache.maven.model.Exclusion exclusion) {        return new Exclusion(exclusion.getGroupId(), exclusion.getArtifactId(), &#34;*&#34;, &#34;*&#34;);    }    private void missingDescriptor(RepositorySystemSession session, RequestTrace trace, Artifact artifact,                                   Exception exception) {        RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.ARTIFACT_DESCRIPTOR_MISSING);        event.setTrace(trace);        event.setArtifact(artifact);        event.setException(exception);        repositoryEventDispatcher.dispatch(event.build());    }    private void invalidDescriptor(RepositorySystemSession session, RequestTrace trace, Artifact artifact,                                   Exception exception) {        RepositoryEvent.Builder event = new RepositoryEvent.Builder(session, EventType.ARTIFACT_DESCRIPTOR_INVALID);        event.setTrace(trace);        event.setArtifact(artifact);        event.setException(exception);        repositoryEventDispatcher.dispatch(event.build());    }    private int getPolicy(RepositorySystemSession session, Artifact artifact, ArtifactDescriptorRequest request) {        ArtifactDescriptorPolicy policy = session.getArtifactDescriptorPolicy();        if (policy == null) {            return ArtifactDescriptorPolicy.STRICT;        }        return policy.getPolicy(session, new ArtifactDescriptorPolicyRequest(artifact, request.getRequestContext()));    }}</code></pre><p><strong>提示：千万不要忘记在Factory内替换DefaultArtifactDescriptorReader为CompactAARArtifactDescriptorReader。</strong></p><h3 id="Aether的版本冲突解决方式与Gradle的不同"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#Aether%E7%9A%84%E7%89%88%E6%9C%AC%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E4%B8%8EGradle%E7%9A%84%E4%B8%8D%E5%90%8C" class="headerlink" title="Aether的版本冲突解决方式与Gradle的不同"></a>Aether的版本冲突解决方式与Gradle的不同</h3><p>假如，使用已经兼容AAR依赖的Aether系统去下载Google的一些库，比如<code>androidx</code>系列，很大概率出现因为依赖冲突而无法下载的问题，或者即使下载了也无法正常编译。</p><p>这个问题是因为Aether和Gradle的默认版本冲突解决方式不同，Aether是就近原则，依赖程度浅的版本则优先度高，Gradle则是就近+最新原则，在本地配置内采用最近原则，在处理远程依赖的子依赖时采用最新版本。</p><h4 id="解决方法-1"><a href="https://xiue233.github.io/2023/09/09/aether-manual/#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>我们只需要改变依赖冲突的解决方式即可，这个需要通过RepositorySystemSession来设置。</p><pre><code class="java">public static RepositorySystemSession newSession(RepositorySystem system, LocalRepository localRepo) {        DefaultRepositorySystemSession session = MavenRepositorySystemUtils.newSession();        session.setConfigProperty(ConflictResolver.CONFIG_PROP_VERBOSE, true);        session.setConfigProperty(DependencyManagerUtils.CONFIG_PROP_VERBOSE, true);        session.setLocalRepositoryManager(system.newLocalRepositoryManager(session, localRepo));        session.setDependencyGraphTransformer(            //改为自定义的DependencyGraphTransformer        );        return session;    }</code></pre><p>自己实现所需的依赖树裁枝方式即可。我这里比较懒省事，直接做一个LazyConflictResolver，下载依赖树上的所有依赖，之后在编译的时候取最新的版本。</p><pre><code class="java">import org.eclipse.aether.RepositoryException;import org.eclipse.aether.collection.DependencyGraphTransformationContext;import org.eclipse.aether.collection.DependencyGraphTransformer;import org.eclipse.aether.graph.DependencyNode;/** * 选择摆烂的ConflictResolver,遇到困难睡大觉，把困难丢给后面的人解决。 */public class LazyConflictResolver implements DependencyGraphTransformer {    @Override    public DependencyNode transformGraph(DependencyNode node, DependencyGraphTransformationContext context) throws RepositoryException {        return node;    }}</code></pre></body></html>