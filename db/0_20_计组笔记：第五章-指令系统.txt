<html><head></head><body><p>指令是硬件和软件的中间层。指令系统的设计主要包括<strong>指令功能</strong>和<strong>指令格式</strong>的设计。它的评价指标有四点：完备（不能缺少功能）、高效（省地方一点）、规整（格式简单一点）、兼容性（向后兼容，无成本迁移）四方面。</p><h2 id="指令的基本格式"><a href="https://mxts.jiujiuer.xyz/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h2><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617201110.png"/></p><p>主要是两部分，首先是<strong>操作码</strong>，其次是数个地址（0个或多个）。将二进制编码用助记符表示，就是汇编语言。</p><p>计算机的存储方式有<strong>大端存储（从数据的高字节开始存）、小端存储（从数据的低字节开始存）</strong></p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617201456.png"/></p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617201611.png"/></p><p>此外还有<strong>边界对齐</strong>的概念。如图所示：</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617201659.png"/></p><p>还有一种存储模式，<strong>堆栈</strong>。这里的堆栈应该就是栈，堆和栈是俩不一样的东西，堆是存程序malloc的内存的，栈是存程序函数调用开销的，这俩在程序的内存中存储的位置也不一样。</p><p>存储模式也有两类：冯诺依曼结构（程序和数据等价）、哈佛结构（程序和数据不对等）。后者对于流水线结构有优化，能达到流水线的理想性能。现在的芯片内部Cache有的会使用哈佛结构：数据Cache、指令Cache，而外部使用冯诺依曼结构。</p><h2 id="指令的典型分类"><a href="https://mxts.jiujiuer.xyz/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/#%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B8%E5%9E%8B%E5%88%86%E7%B1%BB" class="headerlink" title="指令的典型分类"></a>指令的典型分类</h2><ul><li>数据传送类：频率最高，要快</li><li>算数运算类</li><li>逻辑运算类</li><li>程序控制类<ul><li>转移</li><li>循环</li><li>过程调用、返回指令</li><li>程序自中断指令</li></ul></li><li>系统控制类：特权指令，虚存管理、任务切换、改变处理器工作模式</li><li>数据转换类：可选</li><li>输入输出类：根据统一编址（把接口的寄存器映射到主存，用数据传输指令访问外设）和独立编址，可能没有专门的输入输出指令。</li></ul><h2 id="寻址方式：指令获取操作数的方式"><a href="https://mxts.jiujiuer.xyz/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%8C%87%E4%BB%A4%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F" class="headerlink" title="寻址方式：指令获取操作数的方式"></a>寻址方式：指令获取操作数的方式</h2><ul><li>隐含寻址：例如Intel指令<code>MUL BL</code>，事先规定好了地址在哪</li><li>立即寻址：<img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203658.png"/></li><li>寄存器寻址：<img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203717.png"/></li><li>直接寻址：<img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203731.png"/></li><li>间接寻址：操作数地址的地址，需要访问两次主存，比较慢<img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203746.png"/></li><li>寄存器间接寻址：把上面的地址放在CPU内部寄存器<img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203754.png"/></li><li>基址寻址：用来实现主存分段 <img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203826.png"/></li><li>变址寻址：用来实现数组遍历 <img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203835.png"/></li><li>PC相对寻址：PC指向下一条指令，这个方式给PC加偏移量，所以能用来实现与地址无关的程序设计<img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617203551.png"/></li></ul><p>例如，x86处理器的条件转移指令就是一种PC相对寻址。</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617204150.png"/></p><p>无关位置的程序实现：</p><ul><li>虚存管理：逻辑地址</li><li>内存分段管理：段内偏移</li></ul><p>上面两种方案的缺点是位数多，占用指令存储空间大。</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617204711.png"/></p><h2 id="指令长度设计"><a href="https://mxts.jiujiuer.xyz/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/#%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6%E8%AE%BE%E8%AE%A1" class="headerlink" title="指令长度设计"></a>指令长度设计</h2><ul><li>一般原则<ul><li>指令长度为存储器<strong>最小可寻址单位</strong>的整数倍：（CISC）（x86）</li><li>指令长度一般为<strong>总线宽度</strong>的整数倍：RISC</li></ul></li><li>常用设计方案<ul><li>变长操作码，变长指令码：CISC（x86）</li><li>定长操作码，定长指令码：RISC<ul><li>MIPS，6位定长操作码，32位定长指令码</li><li>RISC-V，7位定长操作码，32位定长指令码</li></ul></li></ul></li></ul><p><strong>操作码</strong>格式分为<strong>定长、变长操作码</strong>，变长操作码为了防止重复指令，得用赫夫曼编码来编制操作码。</p><ol><li>定长操作码</li></ol><p>对于定长操作码，可以将指令从高频到低频排序，依次给从0开始编号。</p><ul><li>优点：操作码构造简单，硬件设计简单，译码速度快</li><li>缺点：操作码占存储空间大，难以扩展</li></ul><ol start="2"><li>变长操作码</li></ol><p>对于变长操作码，按照频率高到低排序，再构造霍夫曼树作为编码结果。</p><p>变长操作码设计原则：</p><ul><li>若指令字长度固定，则长地址码对应短操作码，操作码长度随地址码长度缩短而增加</li><li>如果指令字长度可变，则以指令使用频率为设计依据，高频短码，低频长码</li><li>设计总是<strong>从短码开始</strong>，并且保证现在的操作码和以后扩展的编码能区分</li><li><strong>短码不能是长码的前缀</strong></li></ul><p>根据赫夫曼编码的合并方式不同，得到的结果可能不唯一，但是<strong>平均码长一定是唯一的</strong></p><p>缺点：编码长度种类过多，电路设计困难</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617205817.png"/></p><ol start="3"><li>扩展操作码</li></ol><p>是将赫夫曼编码的码长变为更少的种类。</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618013331.png"/></p><p>可以看到，它编码种类较少的同时，码长也很接近赫夫曼编码。因此实际设计时，一般使用这种设计方式。比如CISC的x86就可以这么设计。</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617210813.png"/></p><p>上面是两种设计方式。一个长度的指令码必须保留一种组合给更长的指令码做前缀。</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618013746.png"/></p><p>因此，上面的操作码可以设计如下：</p><ul><li>三地址：操作码6位，指令数$n_3\leq2^6-1$</li><li>双地址：操作码11位，指令数$n_2\leq(2^6-n_3)\cdot2^5-1$</li><li>单地址：操作码16位，指令数$n_1\leq((2^6-n_3)\cdot2^5-n_2)\cdot2^5-1$</li><li>零地址：操作码32位，指令数$n_0\leq(((2^6-n_3)\cdot 2^5 - n_2)\cdot2^5-n_1)\times2^{16}$</li></ul><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618014509.png"/></p><p>对于上面的问题，相当于计算单地址指令一共有多少个。我们分析如下：</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618014832.png"/></p><p>由上图的不等式能解出来，B类指令最多一共有254条。</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617211810.png"/></p><p>上题还是从短码开始考虑。首先短码有m条，则剩下的前缀有$2^4-m$个。再乘以长码扩展的长度$2^6$，就能得到长码最多的个数。</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618015643.png"/></p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618015933.png"/></p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230617213025.png"/></p><h2 id="5-6-典型指令系统"><a href="https://mxts.jiujiuer.xyz/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/#5-6-%E5%85%B8%E5%9E%8B%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F" class="headerlink" title="5.6.典型指令系统"></a>5.6.典型指令系统</h2><h3 id="Intel-x86"><a href="https://mxts.jiujiuer.xyz/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/#Intel-x86" class="headerlink" title="Intel x86"></a>Intel x86</h3><p>发展：从诞生时的80条指令增长到2015的3600条指令（来源Intel博客）。</p><p>十分复杂，指令集手册5000多页（</p><p>目前在向着RISC的方向均衡。它十分适合高性能计算。</p><h3 id="MIPS"><a href="https://mxts.jiujiuer.xyz/2023/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><p>ARM手册也长，8000多页（</p><p>32位MIPS</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618023229.png"/></p><p>64位MIPS，14种指令格式</p><p><img src="https://mxts.jiujiuer.xyz/img/Pasted%20image%2020230618023357.png"/></p><p>MIPS是arm流行之前，最流行的处理器。</p><p>这一章基本就是这样了。</p></body></html>